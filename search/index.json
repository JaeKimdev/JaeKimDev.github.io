[{"content":"Size Class 사이즈 클래스는 대강의 사이즈를 나타낸다. Regular, Compact로 표현. 화면의 특정 길이에 따라서 제약을 추가하거나 무력화 할 수 있다.\n아이패드와 iOS를 함께 사용하는 유니버셜 앱을 만들 때 하나의 스토리 보드로 구현하는 경우, 혹은 아이패드에서 split view를 대응하는 경우에 유용하다. (보통은 아이패드는 다른 스토리보드로 작업하는 경우가 더 많다.)\n제약이나 요소를 선택 한 후 + 버튼을 눌러서 확인/설정이 가능하다.\nRegular와 Compact에 대한 자세한 내용은 Apple Developer Degisn - Layout페이지 하단에서 확인할 수 있다. 각각의 기기가 가로/세모 모드에서 어떤 사이즈를 갖는지 나와있다.\nSafe Area \u0026amp; Layout Margins Safe Area 컨텐츠를 안전하게 보여줄 수 있는 영역\n기기 별로 서로다른 safe area를 가지고 있다.\n기기 크기 / 홈버튼 / 홈바 / 노치 등에 따라서 잘리지 않고 안전하게 보여줄 수 있는 영역을 나타낸다.\n필요에 따라 Safe Area 변경도 가능하다. 가령 앱 안에 사이드 바나 툴바를 사용한다고 하면 additionalSafeAreaInsets 프로퍼티를 수정해서 safe area를 변경할 수 있다. Layout Margins 컨텐츠와 뷰의 경계 사이의 간격을 나타낸다. 왼쪽은 margin을 동일하게 6으로 설정한 경우, 오른쪽은 각각 다른 값으로 설정한 경우이다.\n제약을 추가할 때 Constrain to margins를 체크하면 margin을 기준으로 제약을 추가할 수 있다.\n기본적으로 margin의 방향은 top, bottom, left, right로 설정되어 있지만, 언어의 방향을 따라(아랍어는 오른쪽에서 왼쪽으로 읽는다) directionalLayoutMargins 프로퍼티를 사용해서 top, bottom, leading, trailing로 설정할 수 있다.\nMapView를 하나 올려두고 제약을 걸어보도록 하자. 맵킷이 올라갈 부모뷰와 관계를 맺어야 하기 때문에 SafeArea가 아닌 View를 기준으로 제약을 설정해야 한다.\n동일하게 제약을 걸어주었지만, 왼쪽은 Constrain to margins를 체크하지 않았고, 오른쪽은 체크했다.\nView에 기본적으로 margin이 걸려있다고 볼 수 있는데 뷰를 선택하고 size inspector를 보면 Default로 margin이 설정되어 있고, Language directional을 선택하여 보면 20씩 걸려 있는 것을 확인할 수 있다.\nSafe Area \u0026amp; Layout Margins에 대해 조금 더 알아보고 싶다면 WWDC2018 - UIKit: Apps for Every Size and Shape을 참고해봐도 좋겠다.\nReference Auto Layout Guide - Size Class Specific Layout\nApple Developer Degisn - Layout\nApple Developer - Positioning content relative to the safe area\nApple Developer - Positioning content within layout margins\nWWDC2018 - UIKit: Apps for Every Size and Shape\n야곰닷넷 - 오토레이아웃 정복하기\n","date":"2022-10-11T21:29:28+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/auto-layout7-size-class-/-safe-area-/-layout-margins/","title":"Auto Layout(7) - Size Class / Safe Area / Layout Margins"},{"content":"StackView안에 view를 추가/삭제 할 때 애니메이션 동작과 함께 해보자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import UIKit class StackViewController: UIViewController { let vertical: UIStackView = UIStackView() override func viewDidLoad() { super.viewDidLoad() //button 만들기 vertical.axis = .vertical vertical.translatesAutoresizingMaskIntoConstraints = false view.addSubview(vertical) let horizontal = UIStackView() horizontal.axis = .horizontal horizontal.translatesAutoresizingMaskIntoConstraints = false vertical.spacing = 10 vertical.distribution = .fillEqually view.addSubview(horizontal) let addButton = UIButton() addButton.setTitle(\u0026#34;add\u0026#34;, for: .normal) addButton.setTitleColor(.blue, for: .normal) addButton.addTarget(self, action: #selector(addView), for: .touchUpInside) let removeButton = UIButton() removeButton.setTitle(\u0026#34;remove\u0026#34;, for: .normal) removeButton.setTitleColor(.blue, for: .normal) removeButton.addTarget(self, action: #selector(removeView), for: .touchUpInside) horizontal.addArrangedSubview(addButton) horizontal.addArrangedSubview(removeButton) horizontal.distribution = .fillEqually let safeArea = view.safeAreaLayoutGuide horizontal.bottomAnchor.constraint(equalTo: safeArea.bottomAnchor).isActive = true horizontal.leadingAnchor.constraint(equalTo: safeArea.leadingAnchor).isActive = true horizontal.trailingAnchor.constraint(equalTo: safeArea.trailingAnchor).isActive = true vertical.topAnchor.constraint(equalTo: safeArea .topAnchor).isActive = true vertical.bottomAnchor.constraint(equalTo: horizontal.topAnchor).isActive = true vertical.leadingAnchor.constraint(equalTo: horizontal.leadingAnchor).isActive = true vertical.trailingAnchor.constraint(equalTo: horizontal.trailingAnchor).isActive = true } @objc func addView() { let view = UIView() view.backgroundColor = .black view.isHidden = true // view를 숨겨둔 상태로 먼저 추가한 다음 vertical.addArrangedSubview(view) UIView.animate(withDuration: 0.3) { view.isHidden = false // 숨김을 해제해 준다 } } @objc func removeView() { guard let last = vertical.arrangedSubviews.last else { return } UIView.animate(withDuration: 0.3) { last.isHidden = true } completion: { (_) in self.vertical.removeArrangedSubview(last) } // completion으로 다 사라지면 제거되게 처리 vertical.removeArrangedSubview(last) } } 적용 전 적용 후 Reference 야곰닷넷 - 오토레이아웃 정복하기\n","date":"2022-10-10T16:30:52+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/auto-layout6-dynamic-stackview/","title":"Auto Layout(6) - Dynamic StackView "},{"content":"스토리 보드를 이용하지 않고 코드로 제약을 만드는 방법\nLayout Anchors NSLayoutConstraint Class Visual Format Language (이 방법은 비추천) Preview - 스토리 보드를 이용하는 방법 만약 하단의 버튼을 좌,우 아래쪽에 20의 여백울 준 다음, 홈버튼이 없는 아이폰으로 변경해 보면 하단 여백이 더 길게 보이게 된다.\nSafe Area가 아니라 SuperView에서 20보다 크거나 같다고 지정해 주고,\nButton의 bottom을 SafeArea의 bottom과 같게 지정해 주면 된다.\n하지만 이 상태에서 다시 작은 화면의 기기로 변경하면 Safe Area가 없기 때문에 바닥에 붙어서 보이게 된다. 우리는 20만큼 떨어트리고 싶기 때문에, button의 bottom 제약의 priority를 20만큼의 간격을 갖는 제약보다 낮게 지정해 주면 된다.\nLayout Anchors 각각의 attribute에 앵커를 건다. 가장 간단하고 안전한 방법이다.\n약간의 한계가 존재하기 때문에 NSLayoutConstraint Class를 이용할 수도 있지만 대부분의 경우에는 Layout Anchors를 이용하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class AnchorViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() //버튼 생성 let button = UIButton() button.setTitle(\u0026#34;button\u0026#34;, for: .normal) button.setTitleColor(.white, for: .normal) button.backgroundColor = .systemGreen view.addSubview(button) button.translatesAutoresizingMaskIntoConstraints = false //오토리사이징 마스크라는것을 오토레이아웃의 constraints로 자동으로 변경해줄 것인지 //제대로 이해하고 사용할 것이 아니면 해제해 주는 것이 좋다. //MARK: - 버튼에 Anchor 사용하기 let safeArea = view.safeAreaLayoutGuide //safeArea의 영역을 나타내주는 가이드 //버튼 왼쪽이 safeArea 가이드라인 왼쪽과 16만큼 떨어져있다 button.leadingAnchor.constraint(equalTo: safeArea.leadingAnchor, constant: 16).isActive = true // constraint라는 메서드가 return값으로 \u0026#39;NSLayoutConstraint\u0026#39; 클래스의 인스턴스를 만들어 주기 때문에 // 경고가 떠서 뒤에 .isActive = true 를 넣어줘서 앵커를 만들어주자마자 활성화 시켜준다 // let leadingAnchor = 으로 선언하고 아래에서 사용해도 된다. //버튼 오른쪽 safeArea 가이드라인 오른쪽에서 왼쪽으로 16만큼 떨어져 있다(안으로 들어와야 하기 때문에 음수) button.trailingAnchor.constraint(equalTo: safeArea.trailingAnchor, constant: -16).isActive = true //버텀 앵커 제약 1 = 버튼바닥이 safeArea 가이드라인 바닥과 같다. let safeBottomAnchor = button.bottomAnchor.constraint(equalTo: safeArea.bottomAnchor) safeBottomAnchor.isActive = true safeBottomAnchor.priority = .defaultHigh // = 750 // priority를 원하는 숫자로 지정하려면 rawValue로 지정해주면 된다. // safeBottomAnchor.priority = .init(rawValue: 750) // 버텀 앵커 제약 2 = view의 바닥면에서 안쪽으로 20 보다 같더나 더 멀리 떨어져있다 (안쪽으로 와야 하기 때문에 -이고) // 20과 같거나 안쪽으로 더 많이 떨어져야 하기 때문에 greaterThan을 하면 0쪽으로 이동하고, lessThan을 써야함 let viewBottomAnchor = button.bottomAnchor.constraint(lessThanOrEqualTo: view.bottomAnchor, constant: -20) viewBottomAnchor.isActive = true } } Pros and Cons 앵커를 사용하면 좋은 점은\n코드가 간결해지고 어떠한 제약이 걸려있는지 코드를 읽으면서 확인할 수 있다. 컴파일 타임에 오류를 확인할 수 있다.(버튼의 leading과 SafeArea의 bottom을 연결한다거나..) 주의사항으로는\n.isActive = true 를 해주지 않으면 제약조건이 적용되지 않는다. 조건의 음수, 양수를 잘 생각해야 한다. (안쪽으로 들어와야 하면 음수, 밖으로 나와야 하면 양수) 제약의 first, second Item의 관계를 잘 생각해야 한다. NSLayoutConstraint Class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import UIKit class ConstraintViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() //버튼 생성 let button = UIButton() button.setTitle(\u0026#34;button\u0026#34;, for: .normal) button.setTitleColor(.white, for: .normal) button.backgroundColor = .systemGreen view.addSubview(button) button.translatesAutoresizingMaskIntoConstraints = false let safeArea = view.safeAreaLayoutGuide //safeArea의 영역을 나타내주는 가이드 //버튼 왼쪽이 safeArea 가이드라인 왼쪽과 20만큼 떨어져있다. let leading = NSLayoutConstraint(item: button, attribute: .leading, relatedBy: .equal, toItem: safeArea, attribute: .leading, multiplier: 1, constant: 20) leading.isActive = true //이렇게 활성화해줘도 되고 맨 아래에서 한꺼번에 활성화할 수도 있다. //버튼 오른쪽 safeArea 가이드라인 오른쪽과 20만큼 떨어져있다(안으로 들어와야 하기 때문에 음수) let trailing = NSLayoutConstraint(item: button, attribute: .trailing, relatedBy: .equal, toItem: safeArea, attribute: .trailing, multiplier: 1, constant: -20) //버텀 앵커 제약 1 = 버튼바닥이 safeArea 가이드라인 바닥과 같다. let bottomSafeArea = NSLayoutConstraint(item: button, attribute: .bottom, relatedBy: .equal, toItem: safeArea, attribute: .bottom, multiplier: 1, constant: 0) bottomSafeArea.priority = .defaultHigh // Priority 750으로 낮춰주기 // 버텀 앵커 제약 2 = view의 바닥면에서 안쪽으로 20 보다 같더나 더 멀리 떨어져있다 (안쪽으로 와야 하기 때문에 -이고) // 20과 같거나 안쪽으로 더 많이 떨어져야 하기 때문에 greaterThan을 하면 0쪽으로 이동하고, lessThan을 써야함 let bottomView = NSLayoutConstraint(item: button, attribute: .bottom, relatedBy: .lessThanOrEqual, toItem: view, attribute: .bottom, multiplier: 1, constant: -20) NSLayoutConstraint.activate([trailing, bottomSafeArea, bottomView]) } } 앵커를 사용하다 보면 가끔 안되는 경우가 있는데, 그러한 앵커의 한계점이 있을 때 NSLayoutConstraint을 사용하면 된다. 앵커를 사용할 때와 달리, 컴파일러가 오류를 잡아주지 않기 때문에 주의해야 한다. Outro 스토리 보드에 뷰 컨트롤러를 추가하고 각각의 ViewContrller를 할당하여 확인해 보면 동일한 제약조건이 적용된 것을 볼 수 있다.\nStroyBoard Layout Anchors NSLayoutConstraint Reference Auto Layout Guide- Programmatically Creating Constraints\n야곰닷넷 - 오토레이아웃 정복하기\n","date":"2022-10-09T19:10:14+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/auto-layout5-constraints-with-code/","title":"Auto Layout(5) - Constraints with Code"},{"content":"Type of Errors 충족되지 않은 레이아웃 - constrain만으로 충분하지 않은 경우 애매한 레이아웃 - 제약이 많아서(중복된 제약이 있어서) 어떤 것을 선택해야 할 지 모르는 경우 논리적 오류 - (사람의) 논리적 오류 Unsatisfiable Layouts 충족되지 않은 레이아웃 붉은색 화살표를 따라가면 어떤 제약이 충족되지 않는지 알 수 있다.\n시스템이 런타임중에 충족되지 않은 레이아웃이 감지하면 아래 세가지를 진행한다.\n충돌이 일어난 제약을 알아내고 유효한 레이아웃을 찾을 때까지, 충돌이 일어난 제약을 하나씩 파괴해 보고 콘솔창에 충돌 및 깨진 제약에 대한 로그를 남긴다 충족되지 않은 제약조건을 예방하는 방법은 다음과 같다.\n뷰 계층 구조에 프로그래밍 방식으로 뷰를 추가할 때 만족할 수 없는 제약 조건이 자주 발생한다. 코드로 뷰를 그릴 때에 translatesAutoresizingMaskIntoConstraints 메서드를 false로 설정해야 하는데, 이를 놓치는 경우가 많다. 보여주고 싶은 뷰가 너무 작은 공간에 표시될 때, 자주 발생할 수 있다.\n➡️ 최소 공간을 예측해서 만들거나, 그렇게 할 수 없는 경우에는 필수 제약 조건을 높은 proirity로 설정해서 방지할 수 있다. Ambiguous Layouts 애매한 레이아웃 두 개 이상의 가능성을 가지고 있을 때 애매한 레이아웃이라고 한다.\n애매한 레이아웃을 발견할 수 있는 방법\nbreakpoint를 걸고 lldb 디버깅 메서드를 이용해서 확인할 수 있다.\nhasAmbiguousLayout - 애매한 레이아웃을 가지고 있는지 확인하고 true/false를 반환한다.\nexerciseAmbiguityInLayout - 애매한 레이아웃이 해결된 화면으로 바꾼다. constraintsAffectingLayoutForAxis - 지정된 축을 따라 레이아웃에 영향을 주는 제약의 배열을 반환한다. _autolayoutTrace - 해당 보기를 포함하는 전체 보기 계층 구조에 대한 진단 정보가 포함된 문자열을 반환한다.\nLogical Errors 논리적 오류 사람의 실수로 인해 발생하는 오류이다.\n기존에 걸려있는 제약을 검토하여 빠지거나 중복되는 제약이 있는지 확인 컨텐츠 크기가 중요한 경우 CH, CR 우선순위를 높게 설정 충돌이 날 때까지 명시젝 제약 조건을 추가하여 명확하게 만든다 문제 발생 시 다른 대체 제약 조건을 추가하여 해결 Debugging Tricks and Tips Log 이해 로그를 이해하면 디버깅을 더 쉽게 할 수 있다. 로그 해석이 어려운 경우 로그를 복사하여 Why The Failure, Auto Layout에 븉여 넣어보자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2015-08-26 14:27:54.790 Auto Layout Cookbook[10040:1906606] Unable to simultaneously satisfy constraints. Probably at least one of the constraints in the following list is one you don\u0026#39;t want. Try this: (1) look at each constraint and try to figure out which you don\u0026#39;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you\u0026#39;re seeing NSAutoresizingMaskLayoutConstraints that you don\u0026#39;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints) ( \u0026#34;\u0026lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0\u0026#39;Name\u0026#39;(\u0026gt;=400)]\u0026gt;\u0026#34;, \u0026#34;\u0026lt;NSLayoutConstraint:0x7a895e30 UILabel:0x7a8724b0\u0026#39;Name\u0026#39;.leading == UIView:0x7a887ee0.leadingMargin\u0026gt;\u0026#34;, \u0026#34;\u0026lt;NSLayoutConstraint:0x7a886d20 H:[UILabel:0x7a8724b0\u0026#39;Name\u0026#39;]-(NSSpace(8))-[UITextField:0x7a88cff0]\u0026gt;\u0026#34;, \u0026#34;\u0026lt;NSLayoutConstraint:0x7a87b2e0 UITextField:0x7a88cff0.trailing == UIView:0x7a887ee0.trailingMargin\u0026gt;\u0026#34;, \u0026#34;\u0026lt;NSLayoutConstraint:0x7ac7c430 \u0026#39;UIView-Encapsulated-Layout-Width\u0026#39; H:[UIView:0x7a887ee0(320)]\u0026gt;\u0026#34; ) Will attempt to recover by breaking constraint \u0026lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0\u0026#39;Name\u0026#39;(\u0026gt;=400)]\u0026gt; Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger. The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in \u0026lt;UIKit/UIView.h\u0026gt; may also be helpful. ( )에 있는 메세지를 복사해서 wtf 사이트에 붙여넣기 하고 Go 버튼을 누르면 로그를 해석해준다.\n어떤 제약조건이 있는지 도식화해서 보여주기 때문에 디버깅을 수월하게 할 수 있다.\nLog에 식별자 추가 UILabel:0x7b58b040'Name'.leading과 같이 identifier(Name)를 추가하여 로그를 보기 쉽게 만들 수 있다.\nUIView 요소에 identifier를 추가하려면 identity inspector \u0026gt; Accessibility \u0026gt; identifier에 이름을 넣어주면 된다.\n제약에 identifier를 추가하려면 스토리보드에서 제약을 클릭하고 attributes inspector \u0026gt; identifier에 이름을 넣어주면 된다.\n시뮬레이터에서 뷰와 제약 시각화하기 XCode메뉴 \u0026gt; Debug \u0026gt; View Debugging \u0026gt; show Alignment Rectangles 체크하면 시뮬레이터 상에서 뷰 가장자리와 제약을 시각화 할 수 있다.\nXcode Debug bar에서 Debug View Hierarchy button을 클릭하면 뷰 계층을 볼 수 있다. Reference Auto Layout Guide\n야곰닷넷 - 오토레이아웃 정복하기\n","date":"2022-10-08T13:23:50+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/auto-layout4-debugging-auto-layout/","title":"Auto Layout(4) - Debugging Auto Layout"},{"content":"NumberFormatter 오늘은 스위프트에서 숫자를 표현할 때 사용할 수 있는 NumberFormatter에 대해 알아보자.\nA formatter that converts between numeric values and their textual representations.\n공식문서에서는 숫자 값과 텍스트 표현을 변환하는 포매터(형식)이라고 정의하고 있다.\n단위를 나타낼 때 세자리마다 ,를 찍어준다거나 소숫점 자리수를 제한하거나 할 때 사용한다.\nNumberFormatter Style 여러가지 스타일로 숫자를 표현할 수 있다.\n세자리마다 콤마(,) 표시하기 1 2 3 4 5 6 7 8 9 10 import Foundation // NumberFormatter를 사용하기 위해 Foundation을 import 해준다. let price = 12345600 let formatter = NumberFormatter() formatter.numberStyle = .decimal let formatterResult = formatter.string(for: price) ?? \u0026#34;\u0026#34; print(formatterResult) //12,345,600 소숫점 자리수 제한하기 1 2 3 4 5 6 7 8 let price = 12.345600 let formatter = NumberFormatter() formatter.maximumFractionDigits = 2 // 소숫점 2자리까지 표시 let formatterResult = formatter.string(for: price) ?? \u0026#34;\u0026#34; print(formatterResult) //12.35 원화로 표시하기 1 2 3 4 5 6 7 8 9 let price = 12345600 let formatter = NumberFormatter() formatter.locale = Locale(identifier: \u0026#34;en_KR\u0026#34;) formatter.numberStyle = .currency let formatterResult = formatter.string(for: price) ?? \u0026#34;\u0026#34; print(formatterResult) //₩12,345,600 NumberFormatter 말고도 스위프트에서 제공하는 여러가지 Formatter들이 있음을 알게 되었다.\nDateFormater, ListFormatter, MeasurementFormatter 등등 시간이 날 때 한번씩 들여다 봐야겠다.\nReference Apple Developer Doc - NumberFormatter\nApple Developer Doc - NumberFormatter.Style\n","date":"2022-10-06T19:14:20+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/numberformatter/","title":"NumberFormatter"},{"content":"\n스위프트는 ARC(Automatic Reference Counting)를 사용하여 앱의 메모리 사용량을 관리하고 추적한다. Swift를 효율적으로 사용하기 위해서 ARC가 동작하는 방식을 이해 해보자.\nObject lifetimes and ARC Object lifetime은 init()에서 시작되고 마지막으로 사용되면 끝난다. ARC는 lifetime이 끝난 객체를 deallocate(할당 해제)한다. ARC는 참조 카운트(reference count)를 사용하여 객체의 lifetime을 추적한다. Swift 컴파일러가 retain과 release를 자동으로 삽입한다. reference count가 0이 되면 객체는 deallocate된다. 위의 예제코드에서 Traveler의 참조가 시작되고 끝나는 지점을 확인할 수 있다. traveler1이 Traveler의 인스턴스를 생성하는 시점에 참조가 시작되고, traveler2가 traveler1을 참조하는 시점에 traveler1에 대한 사용이 종료되어 참조가 종료된다.\nSwift 컴파일러는 init()되는 시점에 reference count가 1 올라가고(retain 생략), traveler1에 대한 사용이 끝난 지점에 release를 자동으로 삽입해 준다.\n그렇다면 traveler2 인스턴스에 대한 참조는 어떻게 될까?\ntraveler2가 traveler1을 참조하는 시점에 traveler1에 대한 참조가 시작되고, traveler2의 destination에 \u0026ldquo;Big Sur\u0026quot;를 할당하는 시점에 traveler1에 대한 참조가 종료된다.\nSwift 컴파일러가 시작 전 retain을 삽입하고, traveler2의 마지막 사용(destination에 \u0026ldquo;Big Sur\u0026quot;를 할당)후에 release를 삽입해 준다.\n런타임에서 무슨 일이 일어나고 있는지 그림으로 다시 확인해 보자.\nTraveler 객체는 초기화되면서 Heap영역에 생성되고, reference count가 1로 증가한다.\ntraveler1을 traveler2에 할당하면서 traveler1의 reference count가 2로 증가한다.\ntreveler1의 사용이 완료되어 release가 호출되면서 reference count가 1로 감소한다.\ntraveler2의 destination에 \u0026ldquo;Big Sur\u0026quot;를 할당되어 계속해서 treveler2가 사용되고 있으므로 reference count는 1로 유지된다.\ntraveler2의 사용이 완료되어 release가 호출되면서 reference count가 0이 되고 메모리에서 해제된다.\nobject lifetime in Swift 스위프트에서 객체의 lifetime은 사용기반(use-based)으로 결정된다. 객체의 lifetime은 초기화되는 시점부터 마지막 사용까지 보장된다.\n실제 수명 주기는 컴파일러가 자동으로 삽입해주는 retain과 release에 의해 결정되므로, 최소한으로 보장된 수명주기와 달라질 수 있다.\nObservable object lifetimes 대부분의 경우 객체의 정확한 수명은 중요하지 않을 수 있다.\n하지만 weak, unowned를 사용하거나 Deinitializer side effects와 같은 기능을 사용하는 경우 객체의 수명을 관찰해야 할 필요가 있다.\n생성된 객체가 해제되지 않고 오랫동안 남아있을 가능성도 있고, 컴파일러가 업데이트 되거나 소스코드가 변경되면서 문제가 발생할 가능성이 있다.\nweak and unowned references weak와 unowned 참조는 reference count를 증가시키지 않는다. 따라서 보통 reference cycle을 방지하기 위해 사용한다.\nreference cycle 참조 사이클? 위의 Traveler와 Account 클라스를 살펴보자, Traveler는 account 프로퍼티를 통해 Account를 가지고 있고, Account는 traveler 프로퍼티에서 Traveler를 가지고 있다. 서로가 서로를 참조하고 있기 때문에 reference cycle이 발생한다.\n아래 그림과 같이 test함수를 통해 Traveler 타입과 Account 타입의 인스턴스를 생성하고 lifetime을 살펴보자.\nHeap 영역에 Traveler 타입 인스턴스가 생성되며 reference count는 1로 올라간다.\n다음으로 account 프로퍼티를 통해 Account 타입 인스턴스가 생성되며 reference count는 1로 올라간다. account는 Traveler타입을 참조하으로 Traveler 인스턴스의 reference count는 2로 증가한다.\ntest함수의 3번째 라인을 통해 Traveler 타입의 account 프로퍼티에 Account 인스턴스를 할당한다. 이때 Account 인스턴스의 reference count는 2로 증가한다.\nAccount 타입의 마지막 사용이 끝났기 때문에 Account 인스턴스의 reference count는 1로 감소한다.\ntest함수의 4번째 라인을 통해 Traveler 타입의 마지막 사용이 끝났기 때문에 Traveler 인스턴스의 reference count 역시 1로 감소한다.\n모든 사용이 다 종료 되었지만, Traveler 인스턴스와 Account 인스턴스는 reference count가 0이 되지 않고 계속해서 1로 남아있기 때문에 메모리에서 해제되지 않고 계속해서 남아있으면서 메모리 누수(memory leak)을 발생시킨다. 이러한 상황을 reference cycle 이라고 한다.\nweak, unowned references reference cycle을 해결하기 위해 weak와 unowned 참조를 사용할 수 있다. 메모리에서 해제된 인스턴스를 참조하려고 하면 weak reference 로 선언된 객체는 nil을, unownded reference로 선언된 객체는 trap을 반환한다.\n위의 예제에서 Account 타입의 traveler 프로퍼티를 weak로 선언하면 Traveler 인스턴스의 reference count는 0이 되어 메모리에서 해제된다.\nTraveler 인스턴스가 해제되면서 acount 프로퍼티에 할당된 reference도 해제되기 때문에 Account 인스턴스의 reference count는 0이 되어 메모리에서 해제된다.\n지금까지는 weak를 참조를 끊어주는데(break) 사용했지만, 만약 weak를 객체에 접근할 때 사용한다면 오류를 발생시킬 수 있다.\nprintSummary 메서드는 Account로 이동하였다. test()함수의 traveler.account = account에서 traveler 인스턴스가 마지막으로 사용되고 메모리에서 해제되면 account 인스턴스는 traveler 인스턴스에 접근할 수 없게 된다.\nReference WWDC21 - ARC in Swift: Basics and beyond\nSwift Doc - Automatic Reference Counting ","date":"2022-10-03T20:33:16+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1664800896/960x0_gtyc2h.png","permalink":"https://JaeKimdev.github.io/p/wwdc21-arc-in-swift-basics-and-beyond/","title":"WWDC21 - ARC in Swift: Basics and beyond"},{"content":"Stack View Properties axis(UIStackView Only)\nhorizontal 가로 스택뷰 vertical 세로 스택뷰 distribution: UIStackView.Distribution - 뷰의 사이즈에 관한 방법\nfill: hugging priority가 낮은 친구들이 늘어나서 스택뷰를 채움 fillEqually: 모든 뷰가 동일한 크기로 채워짐 fillProportionally: 컨텐츠 사이즈 비율대로 채워짐(ex\u0026gt; 3:2:4:1) equalSpacing: 기본으로 fill로 작동하고 동일한 간격을 유지 equalCentering: 모든 뷰의 중앙이 동일한 간격을 유지 alignment: UIStackViw.Alingment - 뷰의 위치에 관한 방법\nfill: 스택뷰의 크기에 맞춰서 뷰의 크기가 늘어남 leading: 뷰의 leading이 스택뷰의 leading과 일치 top: 뷰의 top이 스택뷰의 top과 일치 firstBaseline: 뷰의 firstBaseline이 스택뷰의 firstBaseline과 일치 center: 뷰의 center가 스택뷰의 center와 일치 trailing: 뷰의 trailing이 스택뷰의 trailing과 일치\nbottom: 뷰의 bottom이 스택뷰의 bottom과 일치 lastBaseline: 뷰의 lastBaseline이 스택뷰의 lastBaseline과 일치 spacing: CGFloat 요소 사이의 간격\nSimple Stack View Label과 Image View, Button으로 이루어진 Stack View를 만들어보자.\n3가지 요소를 선택한 후, Editor - Embed In - Stack View를 선택한다. 스택뷰를 선택하고 constraints를 상하좌우 0으로 설정해서 화면에 꽉차게 만든다. 이미지가 커지는 것을 원하기 때문에 Image View의 Hugging Priority를 낮게 설정한다.(여기서는 1로 설정했다.) 스택뷰의 Allignment를 Fill로 설정한다. 위쪽 레이블을 선택하고 center로 설정해 준다. Simple Stack View Nested Stack Views View Nested Stack Views name과 text field를 선택하고 Editor - Embed In - Stack View를 선택한다. 만들어준 first, middle, last 스택뷰를 선택하고 다시 하나의 스택뷰에 담아준다 왼쪽의 이미지 뷰와 묶어서 스택뷰를 만들어 준다. 하단 3개의 버튼을 묶어서 스택뷰를 만들고 , 모든 스택뷰를 하나의 스택뷰에 담아준다. Reference Auto Layout Without Constraints\nApple Developer Documentation - UIStackView\nWWDC18 - Mysteries of Auto Layout, Part 1\nAuto Layout Cookbook - StackView\n","date":"2022-09-25T21:03:41+08:00","image":"https://JaeKimdev.github.io/post/swift/220926-14.png","permalink":"https://JaeKimdev.github.io/p/auto-layout3-stack-view/","title":"Auto Layout(3) - Stack View"},{"content":"LLVM(Low-Level-Virtual-Machine) LLDB가 무엇인지 공부하기 위해서, 먼저 LLVM이 무엇인지 알아보자.\n위키에서는\n프로그램을 컴파일 타임, 링크 타임, 런타임 상황에서 프로그램의 작성 언어에 상관없이 최적화를 쉽게 구현할 수 있도록 구성되어 있는 컴파일러 기반 구조\n라고 설명하고 있다.\nLLDB는 LLVM 프로젝트를 통해 개발된 모듈을 디버깅하는 디버거로써 C, C++, Objective-C, Swift를 지원하고 현재는 Xcode에 내장되어 있는 기본 디버거이다.\nXCode에서는 실행중인 프로세스가 breakpoint에서 멈추거나, pause 버튼을 눌러서 실행이 멈추면(단축키: command + control + y) 하단 Debug Area에 LLDB 콘솔이 노출된다.\nLLDB 기본 문법 1 (lldb) command [subcommand] -option \u0026#34;this is argument\u0026#34; command, subcommand, option, argument로 구성되어 있고 띄어쓰기로 구분한다.\ncommand, subcommand : LLDB내의 Object 이름(ex. breakpoint, watchpoint, set, list 등) option : 명령어에 따른 옵션 하이픈(-)으로 시작한다. argument : 명령어에 따른 인자, 공백이 포함될 수도 있기 때문에 큰따옴표(\u0026quot; \u0026ldquo;)로 감싸 주어야 한다. 1 (lldb) breakpoint set --file test.c --line \u0026#34;12\u0026#34; 위 명령어는 test.c 라는 파일의 12번째 라인에 breakpoint를 설정(set)하는 명령어이다.\nHelp 사용 가능한 subcommand나 option을 확인하고 싶을 때는 help 명령어를 사용하면 좋다.\n1 (lldb) help ⬆️ LLDB에서 제공하는 Command 목록을 확인할 수 있다.\n1 (lldb) help breakpoint ⬆️ breakpoint의 subcommand 에 대한 명령어를 확인할 수 있다.\n1 (lldb) help breakpoint set ⬆️ breakpoint set 의 Option을 확인할 수 있다.\nApropos 원하는 기능의 명력어가 있는지 확인하고 싶을 때는 apropos 명령어를 사용할 수 있다.\n1 2 3 4 5 # referent count를 체크할 수 있는 명령어가 있을지 확인하고 싶을 때 (lldb) apropos \u0026#34;refernce count\u0026#34; # The following commands may relate to \u0026#39;reference count\u0026#39;: # refcount -- Inspect the reference count data for a Swift object Breakpoint 디버깅 시 중단점(breakpoint)을 설정하면 해당 위치에서 프로그램의 실행을 멈출 수 있다.\n1 2 3 (lldb) breakpoint set [option] \u0026#34;arguments\u0026#34; # 맨 앞 알파벳만 입력해도 명령어를 실행할 수 있다. same as above (lldb) br s [option] \u0026#34;arguments\u0026#34; Function name 특정 이름을 가진 모든 함수에 -name 옵션을 사용하여 breakpoint를 설정할 수 있다.\n1 2 3 # viewDidLoad 함수에 breakpoint를 설정 (lldb) breakpoint set --name viewDidLoad (lldb) b -n viewDidLoad File name 파일 이름과 line number를 이용하여 breakpoint를 설정할 수 있다.\n1 2 3 # ViewController.swift 파일의 12번째 라인에 breakpoint를 설정 (lldb) breakpoint set --file ViewController.swift --line 12 (lldb) b s -f ViewController.swift -l 12 Condition 조건을 설정하여 breakpoint를 설정할 수 있다.\n1 2 3 4 5 6 7 # viewWillAppear 호출시, animated가 true인 경우에만 break (lldb) breakpoint set --name \u0026#34;viewWillAppear\u0026#34; --condition animated (lldb) br s -n \u0026#34;viewWillAppear\u0026#34; -c animated # ViewControler.swift 파일의 17번째 라인에서 helloWorld가 \u0026#34;abc\u0026#34;인 경우 break (lldb) breakpoint set --file ViewController.swift --line 17 --condition helloWorld == \u0026#34;abc\u0026#34; (lldb) br s -f ViewController.swift -l 17 -c helloWorld == \u0026#34;abc\u0026#34; break list breakpoint list 명령으로 현재 설정된 breakpoint를 확인할 수 있다.\n1 2 3 4 5 6 7 # breakpoint 목록 전체 출력 (lldb) breakpoint list (lldb) br list # breakpoint 목록 간단하게 출력 (brief) (lldb) br list -b # 특정 id를 가진 breakpoint의 정보만 출력 (lldb) br list 1 break delete / disable breakpoint delete 명령으로 설정된 breakpoint를 삭제할 수 있고, breakpoint disable 명령으로 설정된 breakpoint를 비활성화할 수 있다.\n1 2 3 4 5 6 7 8 9 10 # breakpoint 전체 삭제 (lldb) breakpoint delete (lldb) br de # 특정 breakpoint 삭제 (lldb) br de 1 # breakpoint 전체 비할성화 (lldb) breakpoint disable (lldb) br di # 특정 breakpoint 비활성화 (lldb) br di 1 Stepping break되어 있는 상태에서 프로그램의 실행을 한 단계씩 진행시키면서 상태 변화를 관찰할 수 있다.\nstepping over next 명령어를 사용하여 다음 라인으로 진행시킬 수 있다.\n1 2 (lldb) next (lldb) n stepping in step 명령어를 사용하여 다음 statement가 함수인경우 함수 내부의 시작시점으로 진행시킬 수 있다. next명령을 사용했다면 함수를 만나도 다음 statement로 진행시킨다는 점이 다르다.\n1 2 (lldb) step (lldb) s stepping out finish 명령어를 사용하여면 현재 함수가 return될 때까지 진행하고 break된다.\n1 2 (lldb) finish (lldb) f Expression po 객체의 값을 출력할 수 있다.\n1 2 (lldb) po helloWorld (lldb) p helloWorld expression expression 명령어를 사용하여 정보를 출력하고 값을 변경해서 다시 출력할 수도 있다.\nLLDB에서는 내부적으로 값이 출력되면 $R- 형태로 저장되고, 이 값을 다시 사용할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 # view의 정보를 출력 (lldb) expression self.view # $R0이라는 변수에 view의 정보가 저장됨 # $R0의 백그라운드 컬러를 파란색으로 변경 (lldb) expression $R0.backgroundColor = UIColor.blue # Code를 계속 진행 (lldb) continue # view 파란색으로 바뀌어 보여짐 변수를 직접 선언해서 사용할 수도 있다. 이때는 사용하려는 변수명 앞에 $를 붙여줘야 한다.\n1 2 (lldb) expr let $testNumber = 1 (lldb) expr var $testString = \u0026#34;test\u0026#34; --ignore-breakpoints 옵션을 사용하면 breakpoint를 무시하고 코드를 계속 진행시킬 수 있다.\n1 (lldb) expr --ignore-breakpoints Reference 야곰닷넷 - LLDB 정복\nUnderstanding Xcode Build System\nwiki - LLVM\n","date":"2022-09-25T15:33:11+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/lldblow-level-debugger/","title":"LLDB(Low-Level-Debugger)"},{"content":"Auto Layout Guide에서 제공하는 Auto Layout CookBook 따라해보기\nSimple Constraints Single View 1 2 3 4 5 6 7 8 9 10 11 12 13 //Simple Single View Red View.Leading = Superview.LeadingMargin Red View.Trailing = Superview.TrailingMargin Red View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Red View.Bottom + 20.0 //Adaptive Single View Blue View.Leading = Superview.LeadingMargin Blue View.Trailing = Superview.TrailingMargin Blue View.Top = Top Layout Guide.Bottom + Standard (Priority 750) Blue View.Top \u0026gt;= Superview.Top + 20.0 Bottom Layout Guide.Top = Blue View.Bottom + Standard (Priority 750) Superview.Bottom \u0026gt;= Blue View.Bottom + 20.0 Simple Single View Adaptive Single View Two Different-Width Views 오렌지 색 뷰가 항상 보라색 뷰의 두 배의 너비를 가지도록 하기\n1 2 3 4 5 6 7 8 Purple View.Leading = Superview.LeadingMargin Orange View.Leading = Purple View.Trailing + Standard Orange View.Trailing = Superview.TrailingMargin Purple View.Top = Top Layout Guide.Bottom + 20.0 Orange View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Purple View.Bottom + 20.0 Bottom Layout Guide.Top = Orange View.Bottom + 20.0 Orange View.Width = 2.0 x Purple View.Width Interface Builder에서 2.0, 200%, 1/2, 2:1로 여러가지 방법으로 설정할 수 있다.\nLandscape Mode Portrait Mode Two Views with Complex Widths 이번에는 왼쪽의 보라색 뷰가 150pt 최소넓이를 가지는 상태에서 오른쪽 오렌지 뷰가 두 배의 너비를 가지도록 해보자 - 화면이 작은 경우 두배가 안 될 수도 있다. (최소 넓이가 높은 우선순위를 갖는다)\n1 2 3 4 5 6 7 8 9 Blue View.Leading = Superview.LeadingMargin Red View.Leading = Blue View.Trailing + Standard Red View.Trailing = Superview.TrailingMargin Blue View.Top = Top Layout Guide.Bottom + 20.0 Red View.Top = Top Layout Guide.Bottom + 20.0 Bottom Layout Guide.Top = Blue View.Bottom + 20.0 Bottom Layout Guide.Top = Red View.Bottom + 20.0 Red View.Width = 2.0 x Blue View.Width (Priority 750) Blue View.Width \u0026gt;= 150.0 보라색 뷰의 넓이를 150pt로 지정한 후, edit 화면에서 Greater than or Equal을 선택하여 주고, Priority를 1000으로 지정해 준다. 그 후에 오렌지 뷰의 넓이를 2배로 지정해 준 곳에서 우선순위를 750으로 지정해 주면 된다.\nLandscape Mode Portrait Mode 화면 크기가 작은 아이폰 미니 13 세로모드에서는 150pt 우선순위가 먼저 적용되어 2배로 보이지 않는다.\nViews with Intrinsic Content Size Simple Label and Text Field Label과 Text Field를 만들어 주고 아래와 같이 제약을 설정한다. 이름 Label의 너비는 해당 text 크기에 고정되고, Text Field는 나머지 공간에 맞게 확장/축소된다.\n1 2 3 4 5 Name Label.Leading = Superview.LeadingMargin Name Text Field.Trailing = Superview.TrailingMargin Name Text Field.Leading = Name Label.Trailing + Standard Name Text Field.Top = Top Layout Guide.Bottom + 20.0 Name label.Baseline = Name Text Field.Baseline Dynamic Height Label and Text Field 연습 이미지 뷰, 3개의 텍스트 하단에 text view를 가지는 화면을 만들고\n이미지 뷰의 최대 넒이, 높이는 150pt 이미지 뷰의 가로,세로 비율은 1:1 이미지 뷰는 화면 넓이의 30%를 차지 하도록 구성해 보자. Landscape Mode Portrait Mode ❓ 어려웠던 점\n이미지뷰 크기는 화면의 30%를 차지하도록 하려면 어떻게 해야할까?\n➡️ 이미지 뷰를 선택하고 control 키를 누르고 슈퍼뷰에 드레그해서 equal width를 선택하고, 30%를 입력하면 된다. 이미지 뷰의 최대 크기는 150pt을 넘을 수 없으므로 priority를 1000으로 지정하고, 30% 제약은 750으로 지정해 준다. 이미지 뷰 선택하고 control 키를 누르고 이미지 뷰 자신에 끌어 넣으면 보이는 화면에서 aspect ratio를 선택하고 1:1로 지정해 주면 된다. Reference Apple - Auto Layout Guide\n야곰닷넷-오토레이아웃 정복하기\n","date":"2022-09-16T19:55:20+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/auto-layout2/","title":"Auto Layout(2)"},{"content":"프로젝트 README.md 파일을 작성하다보면 프로젝트의 구조를 보여주는 tree 구조를 보여주는 경우가 있다. 이럴 때는 유용하게 사용할 수 있는 tree를 소개한다.\nInstall homebrew가 설치되어 있다면 터미널에서 아래와 같이 입력하면 된다.\n1 brew install tree Usage 사용은 터미널에서 tree 명령어를 입력하면 된다.\n1 tree 아래와 같이 전체 계층 구조를 다 보여준다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 . ├── JuiceMaker │ ├── JuiceMaker │ │ ├── Controller │ │ │ ├── AppDelegate.swift │ │ │ ├── ChangeInventoryViewController.swift │ │ │ ├── HomeViewController.swift │ │ │ └── SceneDelegate.swift │ │ ├── Info.plist │ │ ├── Model │ │ │ ├── Fruit.swift │ │ │ ├── FruitStore.swift │ │ │ ├── Juice.swift │ │ │ ├── JuiceMaker.swift │ │ │ └── MakeFruitError.swift │ │ └── View │ │ ├── Assets.xcassets │ │ │ ├── AccentColor.colorset │ │ │ │ └── Contents.json │ │ │ ├── AppIcon.appiconset │ │ │ │ └── Contents.json │ │ │ └── Contents.json │ │ └── Base.lproj │ │ ├── LaunchScreen.storyboard │ │ └── Main.storyboard │ └── JuiceMaker.xcodeproj │ ├── project.pbxproj │ ├── project.xcworkspace │ │ ├── contents.xcworkspacedata │ │ ├── xcshareddata │ │ │ ├── IDEWorkspaceChecks.plist │ │ │ └── swiftpm │ │ └── xcuserdata │ │ └── smfc.xcuserdatad │ │ └── UserInterfaceState.xcuserstate │ └── xcuserdata │ └── smfc.xcuserdatad │ ├── xcdebugger │ │ └── Breakpoints_v2.xcbkptlist │ └── xcschemes │ └── xcschememanagement.plist └── git -L 옵션을 사용하면 특정 계층까지만 보여줄 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 $ tree -L 1 . ├── JuiceMaker └── git $ tree -L 2 . ├── JuiceMaker │ ├── JuiceMaker │ └── JuiceMaker.xcodeproj └── git Reference https://sourabhbajaj.com/mac-setup/iTerm/tree.html\n","date":"2022-09-16T11:16:41+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1663299814/jexo-tj7Bj_743JA-unsplash_hrm7qw.jpg","permalink":"https://JaeKimdev.github.io/p/%EB%A7%A5-%ED%84%B0%EB%AF%B8%EB%84%90%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-tree-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EB%B3%B4%EB%8A%94-%EB%B0%A9%EB%B2%95/","title":"맥 터미널에서 파일 tree 구조를 보는 방법"},{"content":"Type Alias Declaration Type Alias - 이름 그대로 타입에 별명을 붙이는 것 typealias는 이 존재하는 타입의 이름을 다른 이름으로 바꾸는 것이다.\ndeclarations 1 typealias name = existing type typealias는 새로운 타입을 생성하는 것이 아니라 단순히 이름만 변경하여 사용하는 것이다.\nBuilt-in Type Alias String, Int, Double 등의 기본 타입에 typealias를 사용할 수 있다.\n1 2 3 4 5 6 7 // 일반적으로 사용하는 방법 let name: String = \u0026#34;Jack\u0026#34; // typealias를 사용한 방법 typealias StudentName = String let name: StudentName = \u0026#34;Jack\u0026#34; User-defined Type Alias 사용자가 정의한 타입(class, struct, enum)에 typealias를 사용할 수 있다.\n1 2 3 4 5 6 7 8 9 class student { } // 일반적으로 사용하는 방법 var students: [student] = [] // typealias를 사용한 방법 typealias Students = [Student] var students: Students = [] Complex Type Alias 함수의 매개변수나 반환값에 typealias를 사용할 수 있다.\n1 2 3 4 5 6 7 8 9 // 일반적으로 사용하는 방법 func someMethod(oncomp:(Int)-\u0026gt;(String)){ } // typealias를 사용한 방법 typealias CompletionHandler = (Int)-\u0026gt;(String) func someMethod(oncomp:CompletionHandler){ } Generic Type Alias 제네릭 파라미터를 사용 시 typealias를 사용할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 typealias StringDictionary\u0026lt;Value\u0026gt; = Dictionary\u0026lt;String, Value\u0026gt; typealias StringDictionary2\u0026lt;Value\u0026gt; = [String : Value] // The following dictionaries have the same type. var dictionary1: StringDictionary\u0026lt;Int\u0026gt; = [:] var dictionary2: Dictionary\u0026lt;String, Int\u0026gt; = [:] // generic type으로 선언해줄 때에는 정확한 타입을 명시해주어야 한다. // typealias와 타입은 서로 바꾸어 사용할 수 없고 typealias는 추가적인 제약조건을 도입할 수 없다. typealias DictionaryOfInts\u0026lt;Key: Hashable\u0026gt; = Dictionary\u0026lt;Key, Int\u0026gt; Type Alias in Protocol 1 2 3 4 5 6 7 8 9 10 protocol Sequence { associatedtype Iterator: IteratorProtocol typealias Element = Iterator.Element } func sum\u0026lt;T: Sequence\u0026gt;(_ sequence: T) -\u0026gt; Int where T.Element == Int { // ... } // typealias를 사용하여 T.Iterator.Element 대신 T.Element를 사용할 수 있다. Reference Swift Doc - Type Alias Declaration Swift Typealias\n","date":"2022-09-15T21:18:04+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/typealias/","title":"typealias"},{"content":"Protocols A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements.\n특정 작업이나 기능에 적합한 메소드, 프로퍼티의 청사진\n구조체, 클래스, 열거형에서 프로토콜을 채택(Adopted)하여 사용가능\n추가 기능을 구현하기 위한 protocol extension도 사용할 수 있다.\nProtocol Sysntax 1 2 3 protocol ProtocolName { // protocol definition goes here } 여러개의 프로토콜을 채택할 수도 있다.\n1 2 3 struct SomeStructure: ProtocolName, AnotherProtocol { // protocol definition goes here } 클래스가 다른 클래스를 상속하는 경우에는 부모 클래스를 먼저 적고, 그 다음에 프로토콜을 적는다.\n1 2 3 class SomeClass: Superclass, FirstProtocol, AnotherProtocol { // class definition goes here } Property Requirements 프로토콜에서는 프로퍼티가 저장 프로퍼티인지 연산 프로퍼티인지 명시하지 않고 이름과 타입 그리고 gettable, settable한지 명시한다.\n프로퍼티는 항상 var로 선언해주어야 한다.\n1 2 3 4 protocol SomeProtocol { var mustBeSettable: Int { get set } var doesNotNeedToBeSettable: Int { get } } static접두사를 붙여서 타입 프로퍼티로 선언할 수 있다.\n1 2 3 protocol AnotherProtocol { static var someTypeProperty: Int { get set } } 단일 인스턴스 Property 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // name이라는 프로퍼티를 가지고 있는 프로토콜 구현, 읽기만 가능해도 상관없음(읽기, 쓰기 가능해도 됨) protocol FullyNamed { var fullName: String { get } } // Person 구조체는 FullyNamed 프로토콜을 채택 struct Person: FullyNamed { var fullName: String } let john = Person(fullName: \u0026#34;John Appleseed\u0026#34;) // john.fullName is \u0026#34;John Appleseed\u0026#34; // FullyNamed 프로토콜을 채택한 조금 더 복잡한 Starship 클래스 class Starship: FullyNamed { var prefix: String? var name: String init(name: String, prefix: String? = nil) { self.name = name self.prefix = prefix } var fullName: String { return (prefix != nil ? prefix! + \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) + name } } var ncc1701 = Starship(name: \u0026#34;Enterprise\u0026#34;, prefix: \u0026#34;USS\u0026#34;) // ncc1701.fullName is \u0026#34;USS Enterprise\u0026#34; Method Requirements 프로토콜을 준수하기 위해 특정 메소드 혹은 타입 메소드를 요구할 수 있다.\n프로토콜은 구현을 하지 않는 요구사항이므로 { } 코드 클로저를 사용하지 않고 함수 이름과 매개변수, 반환 타입만 명시한다.\n타입 메소드의 경우 static 접두사를 붙여서 명시한다.\nSyntax 1 2 3 protocol SomeProtocol { static func someTypeMethod() } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // RandomNumberGenerator 프로토콜 구현 protocol RandomNumberGenerator { func random() -\u0026gt; Double } // LinearCongruentialGenerator 구조체는 RandomNumberGenerator 프로토콜을 채택 // 내부에 DOuble을 반환하는 random() 메소드를 구현해주면 된다 class LinearCongruentialGenerator: RandomNumberGenerator { var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -\u0026gt; Double { lastRandom = ((lastRandom * a + c) .truncatingRemainder(dividingBy:m)) return lastRandom / m } } let generator = LinearCongruentialGenerator() print(\u0026#34;Here\u0026#39;s a random number: \\(generator.random())\u0026#34;) // Prints \u0026#34;Here\u0026#39;s a random number: 0.3746499199817101\u0026#34; print(\u0026#34;And another one: \\(generator.random())\u0026#34;) // Prints \u0026#34;And another one: 0.729023776863283\u0026#34; Mutating Method Requirements 값 타입(구조체, 열거형)에서 메소드를 구현할 때는 메소드 앞에 mutating 키워드를 사용해야 한다.\nInitializer Requirements 프로토콜 구현 시, 특정 이니셜라이저를 요구할 수 있다.\n메소드와 마찬가지로 구현부는 작성하지 않는다\n1 2 3 protocol SomeProtocol { init(someParameter: Int) } Class Implementations of Protocol Initializer Requirements 프로토콜을 채택한 Class의 이니셜라이저 구현 클래스에서 프로토콜을 채택한 경우, 이니셜라이저를 구현할 때는 required 키워드를 사용해야 한다.\n1 2 3 4 5 lass SomeClass: SomeProtocol { required init(someParameter: Int) { // initializer implementation goes here } } SomeClass를 상속받는 클래스에서도 해당 프로토콜을 준수해야 하기 때문이다. 따라서 SomeClass가 상속받을 곳이 없는 최종 클래스라면 required 키워드를 사용하지 않아도 된다.\n자식 클래스가 부모 클래스의 지정된 초기화를 재정의하고 프로토콜의 이니셜라이저도 구현해야하는 경우 required override init을 사용한다. 😅\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protocol SomeProtocol { init() } class SomeSuperClass { init() { // initializer implementation goes here } } class SomeSubClass: SomeSuperClass, SomeProtocol { // \u0026#34;required\u0026#34; from SomeProtocol conformance; \u0026#34;override\u0026#34; from SomeSuperClass required override init() { // initializer implementation goes here } } Failable Initializer Requirements 실패할 수 있는 초기화 요구 프로토콜에서도 init?을 사용하여 Failable Initializer를 구현할 수 있다.\n1 2 3 4 5 6 7 8 9 10 protocol SomeProtocol { init?() } // 프로토콜이 failable initializer를 요구해도 init()으로 구현해도 된다 class Some: SomeClass { init() { } //하지만 프로토콜이 init()을 요구하면 init?()으로 구현할 수 없다 Protocols as Types 프로토콜은 실제 기능을 구현하지는 않지만 하나의 독립적인 타입으로 사용할 수 있는 일급시민이다.\n따라서 아래의 3가지가 가능하다\n함수 또는 이니셜라이저의 매개변수 Type or Return Type 상수, 변수 프로퍼티의 Type Array, Dictionary 또는 기타 컨테이너 항목 Type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Dice { let sides: Int // RandomNumberGenerator 프로토콜을 타입으로 사용 let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) { self.sides = sides self.generator = generator } func roll() -\u0026gt; Int { return Int(generator.random() * Double(sides)) + 1 } } var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator()) for _ in 1...5 { print(\u0026#34;Random dice roll is \\(d6.roll())\u0026#34;) } // Random dice roll is 3 // Random dice roll is 5 // Random dice roll is 4 // Random dice roll is 5 // Random dice roll is 4 Reference Apple Docs - Protocols\n","date":"2022-09-12T18:11:48+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/protocols/","title":"Protocols"},{"content":"Understanding Auto Layout Auto Layout dynamically calculates the size and position of all the views in your view hierarchy, based on constraints placed on those views.\n오토 레이아웃은 뷰에 배치된 제약조건(constraints)에 따라 뷰의 크기와 위치를 동적으로 계산해 준다.\nExternal Changes 외부 조건의 변화 사용자가 윈도우 사이즈 조절(Mac OS X) iPad의 스플릿 뷰(Split View)를 나가거나 들어오는 경우(iOS) iOS 기기 로테이트➡️스크린 뱡향 변경(iOS) active call / recording bar가 나타나거나 사라지는 경우(iOS) Internal Changes 내부적 요인의 변화 앱 내부에서 콘텐츠 뷰 사이즈 변경 앱이 Dynamic Type 지원하는 경우 Anatomy of a Constraint 빨간뷰의 머리(Leading)은 파란뷰의 오른쪽 끝(Trailing) + 8 포인트만큼에 위치한다.\nAttribute 크기 Attribute: Width, Height\n위치 Attribure: Top, Bottom, Leading(Left), Trailing(Right), Center X/Y, Baseline(글자의 밑바닥)\nNot An Attribue\n❗️ Attribute 사용 Rule:\n크기 attribue와 위치 attribute를 섞어서 사용 불가능 위치 attribute에 상수 할당 불가(기준이 없기 때문에) Creating Nonambigouos, Statisfiable Layout (모호하지 않은 레이아웃 생성 - 명확하게 지시하기) x축에 한해 1,2,3 모두 계산 가능 superView에서 얼마만큼 떨어져 있는지, 너비를 알려주면 된다.\n가로, 세로화면에서 반씩 차지하는 두개의 view 구성해 보기 두개의 뷰 생성 후 위, 아래 20 포인트씩 제약을 설정한다 좌, 우 20 포인트씩 제약을 설정한다 storyboard에서 에러가 발생하는데 왜지? (좌우 여백을 주었어도 컴퓨터는 사이즈를 알 수 없다) 두개의 뷰를 동시에 선택하고 Equal Width를 선택한다 다른 방법으로는\n빨간색 뷰를 사방으로 20 포인트씩 제약을 설정한다 파른 뷰도 오른쪽으로 20 포인트 제약을 주고, 두개의 뷰를 동시에 선택한 후 Equal Width를 선택한다 두개의 뷰를 동시에 선택하고 Align 버튼을 클릭하여 Top Edges / Bottom Edges를 선택하고 add constraints해 준다 Constraint Priorities \u0026lt;= or \u0026gt;= 연산자를 사용하여 최소 최대 크기를 지정할 수 있다.\nex\u0026gt; 40 \u0026lt;= width \u0026gt;= 280\n다른 뷰가 먼저 자리잡고 난 이후에 최소값과 최대값 사이의 크기로 자리잡는다.\n제약의 우선도(priority)가 달라질 수 있다. 우선도는 제약이 뷰에 가해지는 힘이라고 볼 수 있는데, 여러개의 제약이 존재하는 경우 우선도가 낮은 제약은 무시될 수 있다.\n1~1000까지의 우선도가 있고 높을수록 우선시된다. (기본값은 1000)\nInstrinsic Content Size (고유 컨텐츠 사이즈) 컨텐츠의 사이즈를 기반으로 뷰의 사이즈를 정할 수 있다.(텍스트 길이에 따라 버튼의 사이즈가 정해진다)\n❗️ Slider의 설명 Defines only the width (iOS)는 오류 - Defines only **height\ntext view의 경우 스크롤이 활성화 되어있으면 컨텐츠 사이즈가 정해지지 않고, 스크롤이 비활성화 되어있으면 텍스트 길이에 따라 컨텐츠 사이즈가 정해진다.\nVeiw에 Instrinsic size가 없는 경우 코드를 이용해 사이즈를 정해줄 수 있다. 아래의 코드를 작성하고 view의 identity inspector에서 class명을 myView로 설정해주면 50 x 50의 사이즈를 갖게 설정할 수 있다.\n1 2 3 4 5 6 @IBDesignable class myView: UIView { override var intrinsicContentSize: CGSize { return CGSize(width: 50, height: 50) } } CHCR (Content-Hugging equations and Compression-Resistance) Compression-Resistance:\n외부에서 뷰에 압력이 있을때 줄어들지 않으려고 컨텐츠가 버티려는 힘(가로, 세로) Content-Hugging:\n컨텐츠 사이즈에 맞게 fit하게 맞도록 줄어드는 힘(늘어나지 않으려고하는 힘) 기준이 되는 것은 Instrinsic Content Size이며 CR과 CH 는 priority(우선순위)를 가지고 적용된다.\n3개의 레이블을 만들고 각각 20씩 왼쪽과 오른쪽에 constraint를 설정해 주었다. 레이블의 사이즈가 변해야 하는 경우 Content-Hugging을 1000으로 설정한 첫번째 레이블은 늘어나지 않고, 750으로 설정한 두번째 레이블도 변함이 없고 priority 기본값인 251을 가지고 있는 세번째 레이블이 늘어나서 사이즈를 맞춰주게 된다.\n이번에는 3개의 레이블에 Content Compression-Resistance를 왼쪽부터 250, 750, 1000으로 설정해 주었다.\nCR250으로 설정한 레이블이 극단적으로 늘어나도, 우선순위가 낮기 때문에 750과 1000의 영역으로 컨텐츠를 밀어낼 수 없다. 하지만, CR750으로 설정한 두번째 레이블이 늘어난다면 우선순위가 낮은 첫번째 레이블은 밀려나서 사라지게 되고 CR750 레이블이 덮어버리게 된다. CR1000 레이블이 늘어난다면 길이에 따라 첫번째, 두번째 레이블이 다 가려지게 된다. 늘어나야 하는 경우 Hugging priority가 낮은 녀석이 늘어나고, 줄어들어야 할 경우 Compression-Resistance priority가 낮은 녀석이 줄어들게 된다.\nReference Apple - Auto Layout Guide\n야곰닷넷-오토레이아웃 정복하기\n","date":"2022-09-10T22:15:06+08:00","image":"https://JaeKimdev.github.io/post/swift/220911-1.png","permalink":"https://JaeKimdev.github.io/p/auto-layout1/","title":"Auto Layout(1)"},{"content":"오늘은 UIKit에서 화면전환을 하는 방법을 알아보자.\ninstantiateViewController Creates the view controller with the specified identifier and initializes it with the data from the storyboard.\n애플 문서에서는 지정된 식별자를 가지고 스토리보드의 데이터를 초기화해서 뷰 컨트롤러를 만든다.라고 설명하고 있다.\nStoryboard id를 뷰 컨트롤러의 식별자로 사용한다. instantiateViewController를 이용하여 뷰 컨트롤러를 생성할 때 마다 데이터는 초기화되고 새로운 인스턴스가 생성되기 때문에 이전에 생성했던 데이터를 사용할 수 없다. (ex\u0026gt; 다른 뷰 컨트롤러로 넘어갔다가 돌아오는 경우)\n1 2 3 4 func presentChangeInventoryViewController() { guard let changeInventoryVC = self.storyboard?.instantiateViewController(withIdentifier: \u0026#34;ChangeInventoryViewController\u0026#34;) as? ChangeInventoryViewController else { return } self.present(changeInventoryVC, animated: true) } \u0026ldquo;ChangeInventoryViewController\u0026quot;라는 식별자를 가진 뷰 컨트롤러를 생성하고 스토리보드의 데이터를 초기화한다 = 새로 만들어주겠다는 의미 as? ChangeInventoryViewController as를 이용하여 ChangeInventoryViewController클래스로 타입 캐스팅하여 사용한다. presentChangeInventoryViewController라는 이름의 함수에서 instantiateViewController 메소드를 사용해 주었다.\nperformSegue Initiates the segue with the specified identifier from the current view controller\u0026rsquo;s storyboard file.\n현재 뷰 컨트롤러의 스토리보드 파일에서 지정된 식별자로 segue를 시작한다고 애플 문서에서 설명한다.\nsegue에 정의된 identifier를 사용하여 segue를 시작한다.\n1 2 3 4 func performSegue( withIdentifier identifier: String, sender: Any? ) 화면전환이 일어나기 전에 무조건 뷰 컨트롤러의 prepare(for:sender:)가 호출되기 때문에 데이터를 전달해주고 싶은 경우 오버라이드하여 뷰 컨트롤러의 데이터를 전달할 수 있다.\n1 2 3 4 5 6 override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == \u0026#34;presentChangeInventorySegue\u0026#34; { if let destiVC = segue.destination as? ChangeInventoryViewController{ destiVC.labelText = \u0026#34;Send Data\u0026#34; } } Reference Apple - instantiateViewController(withIdentifier:)\nApple - performsegue\nApple - prepare(for:sender:)\n","date":"2022-09-10T19:56:46+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/instantiateviewcontroller-/-performsegue-%ED%99%94%EB%A9%B4-%EC%A0%84%ED%99%98-%EB%B0%A9%EB%B2%95/","title":"instantiateViewController / performSegue 화면 전환 방법"},{"content":"오늘은 UIViewController의 생명주기에 대해 알아보자.\n그러려면 먼저 UIViewController가 어떤 녀석인지 알아봐야겠지..\nUIViewController An object that manages a view hierarchy for your UIKit app.\n애플 문서에서는 UIKit 앱에서 계층 구조를 관리하는 객체라고 설명되어 있다.\n모든 앱에는 적어도 하나의 UIViewController가 있고 UIViewController는 view를 관리하고, 다른 UIViewController로 전환하거나 view와 사용자 상호 작용을 관리한다.\n아카이브 된 애플문서를 보면 UIViewController가 뷰 계층을 어떻게 관리하는지 더 잘 나와있다.\nHandle view-related notifications view가 변경되면 ViewController 자동으로 자신의 메소드를 호출하여 하위 클래스가 변경사항에 응답할 수 있도록 하는데, 뷰가 보여지고(Appear), 사라지는(Disappear) 일련의 과정들을 생명주기라고 한다.\n애플 문서에 나와있는 이 그림에서는 ViewController가 view의 시각적 상태를 어떠한 메소드를 활용하여 관리하는지 보여준다. will로 시작하는 메소드는 변화가 시작되기 전, did로 시작하는 메소드는 변화가 끝난 후 라고 이해할 수 있겠다. 애플의 Naming 칭찬해 👏\n뭔가 순환하는 듯한 애플의 이미지가 잘 이해가 가지 않는다면 이 그림을 보자\n출처: https://subscription.packtpub.com/book/application-development/9781783550814/6/ch06lvl1sec60/uiviewcontroller-lifecycle-methods loadView Creates the view that the controller manages.\n컨트롤러가 관리하는 뷰를 만들어주는 메소드이다. view property를 할당하여 뷰를 로드하거나 만들어주는 역할을 한다.\n스토리보드나 xib와 같은 interfaceBuilder를 사용하는 경우 nib 파일을 로드하여 자동으로 호출되고, 코드로만 뷰를 구성할 경우 오버라이드 하여 사용해야 한다.\nviewDidLoad Called after the controller\u0026rsquo;s view is loaded into memory.\n컨트롤러의 뷰가 메모리에 로드되었을때 호출된다고 정의되어 있다.\n뷰가 프로그래밍 방식으로 생성되었든지, xib 파일에서 로드되었는지 여부와 상관없이 뷰와 뷰 계층이 메모리에 로드되었을 때 호출된다. 화면에 만들어 질 때 한번만 호출되기 때문에 리소스를 초기화하거나 초기화면을 구성하는 용도로 사용된다.\n새로운 코코아터치 파일을 만들면 보이는 이것! viewDidLoad()\nDo any additional setup after loading the view. 부분에 코드를 넣어주면 된다.\nviewWillAppear Notifies the view controller that its view is about to be added to a view hierarchy.\n뷰가 뷰 계층에 추가될 것이라고 뷰 컨트롤러에게 알리고 뷰를 보여주기 위해 화면을 그리는 동작 이전에 호출된다.\nFor example, you might use this method to change the orientation or style of the status bar to coordinate with the orientation or style of the view being presented.\n화면이 보여지기 전 변경되어야 할 작업들(상태바의 방향(Depth표시 등))을 여기서 먼저 처리하고 뷰를 그려주면 되겠다.\nviewDidAppear Notifies the view controller that its view was added to a view hierarchy.\n뷰 컨트롤러에게 뷰가 추가되었음을 알리는 메소드이다.\nIf a view controller is presented by a view controller inside of a popover, this method is not invoked on the presenting view controller after the presented controller is dismissed.\n💡 popover 내부에서 뷰 컨트롤러가 표시되는 경우 표시된 컨트롤러가 해제되고 보여지는 뷰 컨트롤러에서도 호출되지 않는다.\nviewWillDisappear Notifies the view controller that its view is about to be removed from a view hierarchy.\n뷰 컨트롤러에게 뷰가 제거될 것임을 알리는 메소드이다. 뷰가 실제로 제거되기 전과 애니메이션이 구성되기 전에 호출된다.\nFor example, you might use this method to revert changes to the orientation or style of the status bar that were made in the viewDidAppear(_:) method when the view was first presented.\n이 뷰를 처음 표시할 때 viewDidAppear 메소드에서 처리한 변경된 작업들을 되돌리고 싶은 경우 여기서 처리하면 된다.\nviewDidDisappear Notifies the view controller that its view was removed from a view hierarchy.\n뷰 컨트롤러에게 뷰가 제거되었음을 알리는 메소드이다. 뷰가 실제로 제거된 후에 호출된다.\n생각해보기 ❓ 만약에 홈화면에서 버튼을 클릭하여 다른 화면으로 이동했다가 다시 홈화면으로 돌아오는 경우에는 이렇게 되는 것일까?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //App 실행되고 FirstVC 노출 1. FirstVC loadView 2. FirstVC viewDidLoad 3. FirstVC viewWillAppear 4. FirstVC viewDidAppear //push로 SecondVC 호출 5. SecondVC loadView 6. SecondVC viewDidLoad 7. FirstVC viewWillDisappear 8. SecondVC viewWillAppear 9. FirstVC viewDidDisappear 10. SecondVC viewDidAppear //다시 FirstVC로 돌아오는 경우(Pop) 11. SecondVC viewWillDisappear 12. FirstVC viewWillAppear 13. SecondVC viewDidDisappear 14. FirstVC viewDidAppear 15. Optional(\u0026#34;Second\u0026#34;) 해제됨 // SecondVC deinit 실행 10번 이후에 loadView()와 viewDidLoad()가 없는 이유는 FirstVC는 현재 네비게이션 컨트롤러의 rootView이기 때문에 앱 실행 시 한번만 호출된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //App 실행되고 FirstVC 노출 1. FirstVC loadView 2. FirstVC viewDidLoad 3. FirstVC viewWillAppear 4. FirstVC viewDidAppear //present로 SecondVC 호출 5. SecondVC loadView 6. SecondVC viewDidLoad 7. SecondVC viewWillAppear 8. SecondVC viewDidAppear //다시 FirstVC로 돌아오는 경우(Dismiss) 9. SecondVC viewWillDisappear 10. SecondVC viewDidDisappear 11. Optional(\u0026#34;Second\u0026#34;) 해제됨 // SecondVC deinit 실행 present Modality를 사용해서 뷰 컨트롤러를 호출하는 경우, SecondVC만 로드되어 호출되고 FirstVC는 아래쪽에 남아있어 Dismiss될 때 FirstVC의 viewWillDisappear viewDidDisappear가 호출되지 않는다.\nReference Apple - UIViewController\nApple - View Controller Programming Guide for iOS\nApple - loadView()\nApple - viewDidLoad()\nApple - viewWillAppear(_:)\nApple - viewDidAppear(_:)\nApple - viewWillDisappear(_:)\nAplle - viewDidDisappear(_:)\nZedd - View Controller의 생명주기\nViewController의 LifeCycle\n","date":"2022-09-07T09:32:29+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/uiviewcontroller-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0lifecycle-methods-view-state-method/","title":"UIViewController 생명주기(lifecycle methods - View State Method)"},{"content":"Foundation 프레임워크에서 Swift 문법 공부만 하다가 이제 드디어 UIKit을 사용해보게 되었다.\nAlert을 구현해보고 싶었는데 어떻게 할지 몰라서 찾아보고 미래의 나를 위해 포스팅한다.\nAlert - Human Interface Guidelines An alert gives people critical information they need right away.\nHIG 문서에서는 Alert을 사람들에게 필요한 정보를 즉시 제공하는 컴포넌트라고 정의되어 있다.\nalerts display a title, optional informative text, and up to three buttons\n➡️ 제목과 선택적 정보 텍스트, 최대 3개의 버튼을 표시할 수 있다. (하지만 얼럿에서 3개의 버튼은 보지 못한거 같다.)\nPlace buttons where people expect. In general, place the button people are most likely to choose on the trailing side in a row of buttons or at the top in a stack of buttons. Always place the default button on the trailing side of a row or at the top of a stack. Cancel buttons are typically on the leading side of a row or at the bottom of a stack.\n✅ 사람들이 기대하는 곳에 버튼을 놓고 - 일반적으로 사용자가 선택할 가능성이 가장 높은 버튼을 제일 뒤에 위치시키고, 취소 버튼은 일반적으로 맨 앞에 위치.\nIdentify destructive buttons. If an alert button results in a destructive action, like deleting content, specify the destructive button style to help people recognize it.\n✅ 얼럿 버튼이 내용 삭제와 같은 파괴적인 결과를 나타낸다면 destructive 스타일로 지정하여 사람들이 인지할 수 있도록 한다.\nAlways use “Cancel” to title a button that cancels the alert’s action.\n✅ 얼럿을 취소하는 버튼의 이름은 항상 Cancel(취소)로 한다.\nyou can use “OK” for acceptance, avoiding “Yes” and “No”\n✅ 간단한 승인을 위해서 OK를 사용해도 되지만 Yes(예)와 No(아니오)를 사용하지 않는다.\nEnable alternative ways to cancel an alert when it makes sense.\n✅ 경고를 취소하는 다른 방법을 활성화한다. iOS에서는 홈 화면으로 이동하거나 연결된 키보드의 esc키를 누르는 방법으로도 취소할 수 있어야 한다.\nAlert 만들기 IBAction 만들기 StoryBoard에서 버튼을 하나 생성해주고 Ctrl버튼을 누른채로 코드쪽으로 드래그 하면 IBAction이 생성된다.\nIBAction 함수가 생기는데 이 함수 내부에 코드를 작성해줄 것이다.\nAlert 설정 1 let alret = UIAlertController(title: \u0026#34;알림 제목\u0026#34;, message: \u0026#34;알림창 내용\u0026#34;, preferredStyle: .alert) preferredStyle에 .alert를 사용하면 알림창이 나오고, .actionSheet을 사용하면 액션시트가 나온다.\n아래에서 위로 올라오는 이렇게 생긴 녀석이 actionSheet이다.\nAlert에 들어갈 Action 버튼 설정 얼럿에서 노출되는 버튼을 따로 구현해 주어야 한다.\n1 2 let ok = UIAlertAction(title: \u0026#34;OK\u0026#34;, style: .default, handler: nil) let cancel = UIAlertAction(title: \u0026#34;Cancel\u0026#34;, style: .destructive, handler: nil) style에서 cancel이 default보다 굵은 글씨로 노출되고, destructive는 빨간색으로 노출된다.\nhandler에서는 사용자가 버튼을 누르면 어떤 일이 일어날지 정의해준다. 클로저를 열어서 버튼 클릭 시 작동할 코드를 적어주면 된다. nil 작성 시 얼럿만 닫히고 아무 일도 일어나지 않는다.\n1 2 3 4 5 let something = UIAlertAction(title: \u0026#34;DoSomthing\u0026#34;, style: .default, handler: {action in print(\u0026#34;DoSomthing\u0026#34;) }) Alert에 액션 버튼을 추가해주기 얼럿의 제목과 메세지를 보여주는 얼럿 프레임(?)과 얼럿의 버튼이 될 액션 버튼을 정의해 주었으니, 이제 얼럿에 추가해주는 작업을 해 주어야 한다.\n1 2 alret.addAction(cancel) alret.addAction(ok) ❗️ 추가하는 순서대로 얼럿 버튼이 노출된다. 처음 읽었던 HIG에 따르면 취소 버튼은 제일 앞에 위치해야 하기 때문에 제일 먼저 추가해주어야 한다.\n액션버튼을 정의해 줄 때 cancel 버튼의 스타일을 destructive로 설정했기 때문에 빨간색으로 노출된다.\n1 2 3 alret.addAction(cancel) alret.addAction(ok) alret.addAction(something) handler에 클로저를 적용한 something도 추가해 보았다. HIG에 버튼은 최대 3개까지 추가할 수 있다고 해서 어떻게 노출되는지 궁금했다. DoSomething을 선택하면 클로저에 작성한 print문이 실행된다.\nAlert view 화면에 뜰 수 있게 설정 1 present(alret, animated: true, completion: nil) present메소드를 사용해서 얼럿을 뜨게 만들어 준다.\nanimated는 얼럿이 노출될 때 어떤 애니메이션을 적용할지 설정한다. true로 설정하면 부드럽게 뜨고, false로 설정하면 바로 뜨게 된다.\ncompletion은 completion: { }) 형태로 클로저 안에 코드를 작성해 줄 수 있다. 해당 얼럿이 노출되고 추가로 할 일을 지정해 줄 수 있겠다.\nanimated-true animated-false 요약 얼럿 Frame을 만들어 준다. 1 let alret = UIAlertController(title: \u0026#34;알림 제목\u0026#34;, message: \u0026#34;알림창 내용\u0026#34;, preferredStyle: .alert)​ 액션 버튼을 정의해준다. 1 2 let ok = UIAlertAction(title: \u0026#34;OK\u0026#34;, style: .default, handler: nil) let cancel = UIAlertAction(title: \u0026#34;Cancel\u0026#34;, style: .cancel, handler: nil) 얼럿 frame과 버튼을 addAction 메서드를 이용해서 바인딩해 준다. 1 2 alret.addAction(cancel) alret.addAction(ok) present메소드를 사용해서 얼럿을 뜨게 만들어 준다. 1 present(alret, animated: true, completion: nil) Full Code 1 2 3 4 5 6 7 8 9 10 11 12 @IBAction func showAlert(_ sender: UIButton) { let alret = UIAlertController(title: \u0026#34;알림제목\u0026#34;, message: \u0026#34;알림창 내용\u0026#34;, preferredStyle: .alert) let ok = UIAlertAction(title: \u0026#34;OK\u0026#34;, style: .default, handler: (nil)) let cancel = UIAlertAction(title: \u0026#34;Cancel\u0026#34;, style: .cancel, handler: nil) alret.addAction(cancel) alret.addAction(ok) present(alret, animated: false, completion: nil) } } Reference Apple HIG - Alerts\nApple HIG - Action sheets\nZedd - 왕초보를 위한 Alert View사용해보기\nAri - Alert 알림창을 만들어보자\n","date":"2022-09-04T16:02:57+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/alert-actionsheet/","title":"Alert, ActionSheet"},{"content":"Notification A container for information broadcast through a notification center to all registered observers.\n애플 공식문서에서는 노티피케이션을 \u0026ldquo;모든 등록된 옵저버에게 브로드캐스트되는 정보의 컨테이너\u0026quot;라고 정의하고 있다.\nNotificationCenter라는 싱글턴 객체를 통해 이벤트 발생여부를 옵저버를 등록해 놓은 객체들에게 Notification을 post하는 방법으로 사용할 수 있다. Notification.Name이라는 값을 통해서 이벤트를 구분할 수 있다.\nNotificationCenter A notification dispatch mechanism that enables the broadcast of information to registered observers.\n애플 공식문서에서는 \u0026ldquo;등록된 옵저버에게 정보를 브로드캐스트 할 수 있는 발송 매커니즘\u0026rdquo; 이라고 정의한다.\nNotificationCenter ➡️ Notification 사용방법 NotificationCenter에 Observer 등록하기 유투브에서 원하는 채널의 구독 설정을 하는 것과 같이, 관찰하고 싶은 이벤트를 addObserver를 사용해서 등록해야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Son { let name: String var pocketMoney: Int init(name: String, pocketMoney: Int) { self.name = name self.pocketMoney = pocketMoney // NotificationCenter에 Observer 등록하기 - 구독 설정 NotificationCenter.default.addObserver(self, selector: #selector(answerToDaddy(_:)), name: Notification.Name.toDo, object: nil) @objc func answerToDaddy(_ noti: Notification) { // notification.userInfo 값을 받아온다. guard let object = noti.userInfo?[ToDoList.math] as? String else { return } print(\u0026#34;\\(name): 오늘의 할일은 \\(object)입니다.\u0026#34;) } } } name과 pocketMoney을 프로퍼티로 가지는 Son이라는 클라스를 만들고 초기화 시 NotificationCenter에 Observer를 등록한다.\n1️⃣ self : notification의 관찰자(observer)가 될 object ➡️ 여기서는 자기 자신(Son)\n2️⃣ selector : notification이 오면 실행할 함수 (등록한 이름의 노티를 받으면 answerToDaddy(_:)를 실행한다.)\n3️⃣ name : notification의 이름 (Notification.Name(\u0026quot;이름\u0026quot;)이렇게 등록하고 post와 맞춰도 된다. 여기서는 Extension으로 지정해 줌)\n4️⃣ object : 지정하면 특정 sender로부터만 notification을 받음 (optional)\n1 2 3 4 NotificationCenter.default.addObserver(self, selector: #selector(answerToDaddy(_:)), name: Notification.Name.toDo, object: nil) ⬆️ toDo라는 이름의 notification을 받으면 answerToDaddy(_:)를 실행한다.\nNotificationCenter로 Post하기 (발송하기) .post를 사용하여 NotificationCenter로 Notification을 보낼 수 있다.\nDad라는 클라스에서 toDo라는 이름으로 Notification를 NotificationCenter로 발송한다.\n1️⃣ name : 발송하고자 하는 notification의 이름 (이걸 통해 알림을 식별)\n2️⃣ object : 특정 sender의 notification만 받고 싶은 경우에 작성 (없으면 nil)\n3️⃣ userInfo : notification과 관련된 값 = extra data를 보내는데 사용한다. (없으면 nil)\n이때 userInfo의 타입은 위에서 말했다시피 [Anyhasable : Any] 이기 때문에 다운캐스팅해서 원하는 타입에 맞춰 작성해주면 된다.\n1 2 3 4 5 6 7 8 9 10 class Dad { func callSon() { print(\u0026#34;what\u0026#39;s your chore for Today?\u0026#34;) // NotificationCenter로 Post 발송 NotificationCenter.default.post(name: Notification.Name.toDo, object: nil, userInfo: [ToDoList.math: \u0026#34;수학 문제풀기\u0026#34;]) } } removeObserver addObserver 이후에 removeObserver를 사용하여 등록한 Observer를 제거할 수 있다.\nIf your app targets iOS 9.0 and later or macOS 10.11 and later, and you used addObserver(_:selector:name:object:) to create your observer, you do not need to unregister the observer. If you forget or are unable to remove the observer, the system cleans up the next time it would have posted to it.\n애플 문서에서는 앱이 iOS 9 이이상을 타겟으로 한다면 자동으로 옵저버를 정리해 준다고 되어 있지만, 삭제 시점이 내가 원하는 시점이 아닐 수 있으니 deinit을 사용하여 옵저버를 제거해 주는 것이 좋다.\n장 / 단점 장점 많은 코드를 작성할 필요 없이 구현이 비교적 간단하다. 일대다 방식으로 여러 객체에 쉽게 알림을 보내줄 수 있다. Notification과 관련된 정보를 Any? 타입의 object, [AnyHashable: Any]? 타입의 userInfo로 전달받아 사용할 수 있다. 단점 제어 프로세스의 추적이 어려울 수 있다. 등록된 개체는 알림센터에서 등록을 취소해주어야 한다. post한 이후의 피드백을 받을 수 없다. 컨트롤러와 관찰자 개체간의 연결 관리를 위해서는 제 3자 개체가 필요하다. 예제코드 풀버전 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // extension으로 Notification Name 설정 (호출 시 용이) extension Notification.Name { static let toDo = Notification.Name(\u0026#34;toDo\u0026#34;) static let pocketMoney = Notification.Name(\u0026#34;pocketMoney\u0026#34;) } // Notification과 관련된 인스턴스 enum ToDoList { case math case reading case pushUp } class Dad { func callSon() { print(\u0026#34;what\u0026#39;s your chore for Today?\u0026#34;) // NotificationCenter로 `toDo`라는 이름의 Post 발송 NotificationCenter.default.post(name: Notification.Name.toDo, object: nil, userInfo: [ToDoList.math: \u0026#34;수학 문제풀기\u0026#34;]) } func askHowMuchSonHave() { print(\u0026#34;How much do you Have money?\u0026#34;) // NotificationCenter로 `pocketMoney`라는 이름의 Post 발송 NotificationCenter.default.post(name: Notification.Name.pocketMoney, object: nil) } } class Son { let name: String var pocketMoney: Int init(name: String, pocketMoney: Int) { self.name = name self.pocketMoney = pocketMoney // NotificationCenter에 `toDo`라는 이름의 Observer 등록하기 - 구독 설정 NotificationCenter.default.addObserver(self, selector: #selector(answerToDaddy(_:)), name: Notification.Name.toDo, object: nil) // NotificationCenter에 `pocketMoney`라는 이름의 Observer 등록하기 NotificationCenter.default.addObserver(self, selector: #selector(toTellDaddyHowMuchIHave(_:)), name: Notification.Name.pocketMoney, object: nil) } deinit { NotificationCenter.default.removeObserver(self, name: Notification.Name.toDo, object: nil) NotificationCenter.default.removeObserver(self, name: Notification.Name.pocketMoney, object: nil) } @objc func answerToDaddy(_ noti: Notification) { // notification.userInfo 값을 받아온다. guard let object = noti.userInfo?[ToDoList.math] as? String else { return } print(\u0026#34;\\(name): 오늘의 할일은 \\(object)입니다.\u0026#34;) } @objc func toTellDaddyHowMuchIHave(_ noti: Notification) { print(\u0026#34;\\(name): 제가 가진 용돈은 \\(pocketMoney)원 입니다.\u0026#34;) } } class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Dad 인스턴스 생성 let jae: Dad = Dad() // Son 인스턴스 생성 - init하면서 옵저버 등록됨 let sion: Son = Son(name: \u0026#34;Sion\u0026#34;, pocketMoney: 1000) let smith: Son = Son(name: \u0026#34;Smith\u0026#34;, pocketMoney: 500) let matthew: Son = Son(name: \u0026#34;Matthew\u0026#34;, pocketMoney: 3800) // jae가 NotificationCenter에 post 한다 jae.callSon() jae.askHowMuchSonHave() } } // what\u0026#39;s your chore for Today? // Sion: 오늘의 할일은 수학 문제풀기입니다. // Smith: 오늘의 할일은 수학 문제풀기입니다. // Matthew: 오늘의 할일은 수학 문제풀기입니다. // How much do you Have money? // Sion: 제가 가진 용돈은 1000원 입니다. // Smith: 제가 가진 용돈은 500원 입니다. // Matthew: 제가 가진 용돈은 3800원 입니다. Reference Apple - notification\nApple - notificationcenter\nApple - removeObserver(_:)\nAri - Notification, NotificationCenter\nKio - TIL\nDelegate, NOTIFICATION,KVO pros and cons\n","date":"2022-09-03T23:16:23+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/notification-notificationcenter/","title":"Notification, NotificationCenter"},{"content":"KVO (Key-value observing) Key와 Value의 쌍으로 옵저빙하는 것\nKey-value observing is a Cocoa programming pattern you use to notify objects about changes to properties of other objects. It’s useful for communicating changes between logically separated parts of your app—such as between models and views. You can only use key-value observing with classes that inherit from NSObject.\n다른 객체의 프로퍼티 변경사항을 객체에게 알려주는 코코아 프로그래밍 패턴\nModel과 View와 같이 논리적으로 분리된 파트사이에서 변경사항을 전달하는 데 유용하다.\nobjective-c에서 사용하던 방식이라고 생각하면 된다.\nNSObject를 상속하는 클래스만 key-value observing을 사용할 수 있다.\nObservig을 하기 위한 초기 설정(Annotate a Property for Key-Value Observing) 1 2 3 4 5 6 7 8 9 class Person { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } } 이름과 나이를 프로퍼티로 가지는 Person이라는 클라스가 있다고 했을 때, KVO를 적용하기 위해서는 무엇을 해야 할까?\nNSObject를 상속하는 클래스를 정의한다. 상속을 받아야 하기 때문에 class에서만 가능하다. observe 하려는 프로퍼티에 @objc attribute와 dynamic modifier를 붙여준다. 1 2 3 4 5 6 7 8 9 class Person: NSObject { var name: String @objc dynamic var age: Int init(name: String, age: Int) { self.name = name self.age = age } } Obsever 정의(Define an Observer) 1 2 3 4 5 6 7 8 9 10 11 12 var jae: Person = Person(name: \u0026#34;Jae\u0026#34;, age: 20) var gundy: NSKeyValueObservation? gundy = jae.observe( \\Person.age, options: [.old, .new] ) { object, change in print(\u0026#34;\\(object.name)의 나이는 \\(change.oldValue!)에서 \\(change.newValue!)으로 변경되었다.\u0026#34;) } jae.age = 21 // Jae의 나이는 20에서 21으로 변경되었다. jae라는 이름의 Person 인스턴스를 생성하고 20살로 설정하였다. gundy라는 이름의 변수(예제가 Person 타입이라 사람으로 지정했고 애플 사이트에서는 observation으로 되어 있다)에 jae의 age 프로퍼티에 대한 옵저버 NSKeyValueObservation을 저장한다. 이제부터는 jae의 age 값이 변경될 때마다, gundy에게 알려주게 된다.\nObserving이라는 네이밍이 다른 객체가 jae를 들여다보고 있는 것 같지만, 실제로는 jae 자신이 들여다보고 있다가 값이 변경되면 gundy에게 Optional 값으로 알려주는 형태이다.\ngundy는 jae가 보내준 노티를 받으면 { }안의 코드(여기서는 값이 바뀜을 출력)를 실행한다. If you don’t need to know how a property has changed, omit the options parameter. Omitting the options parameter forgoes storing the new and old property values, which causes the oldValue and newValue properties to be nil.\n애플 문서에서는 속성이 어떻게 변경되었는지 알 필요가 없는 경우 옵션 매개변수 options: [.old, .new]를 생략할 수 있고, 이 경우에는 oldValue와 newValue 프로퍼티가 nil이 된다. ➡️ 그럼 KVO를 왜 쓰는거지❓\n1 2 3 4 5 6 gundy = jae.observe( \\Person.age ) { object, change in print(\u0026#34;\\(object.name)의 나이는 \\(change.oldValue)에서 \\(change.newValue)으로 변경되었다.\u0026#34;) } jae.age = 21 // Jae의 나이는 nil에서 nil으로 변경되었다. KVO 장단점 장점 두 객체 사이의 동기화가 용이하다. 관찰된 프로퍼티의 oldValue와 newValue를 얻을 수 있다. KeyPath를 가져오기 때문에(\\Person.age) Nested object를 관찰할 수 있다. 단점 NSobject를 상속받는 객체에서만 사용이 가능하다.\n여러값을 관찰할 때는 복잡한 if문을 사용해야 한다.\nReference Using Key-Value Observing in Swift\nNSKeyValueObservingOptions Zedd - Key-Value Observing(KVO) in Swift\nKey-Value Coding(KVC) / KeyPath in Swift\nleeari95 - KVO(Key-value observing)\nDelegate, NOTIFICATION,KVO pros and cons\n","date":"2022-09-03T19:04:50+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/kvokey-value-observing/","title":"KVO(Key-value observing)"},{"content":"Cocoa Touch Framework 싱글턴 디자인 패턴을 공부하던 중, 함께 공부해야 하는 키워드에 Cocoa Touch Framework이 있었다.\n❓ 나는 코코아터치도 모르고 싱글턴도 모르는데;;\n오늘은 프레임워크와 코코아 / 코코아터치 프레임워크에 대해 전반적으로 알아보자.\nCocoa and Cocoa Touch are the application development environments for OS X and iOS, respectively. Both Cocoa and Cocoa Touch include the Objective-C runtime and two core frameworks:\nCocoa, which includes the Foundation and AppKit frameworks, is used for developing applications that run on OS X.\nCocoa Touch, which includes Foundation and UIKit frameworks, is used for developing applications that run on iOS.\n아카이브 된 애플 문서를 보면\nCocoa는 Foundation과 AppKit 프레임워크를 포함하고 있고, 맥 OS X에서 실행되는 어플리케이션 개발에 사용되고\nCocoa Touch는 Foundation과 UIKit 프레임워크를 포함하고 있고, iOS에서 실행되는 어플리케이션 개발에 사용된다고 정의되어 있다.\nFramework \u0026ldquo;A framework is a hierarchical directory that encapsulates shared resources, such as a dynamic shared library, nib files, image files, localized strings, header files, and reference documentation in a single package.\u0026rdquo;\n일단 프레임워크가 무엇인지 찾아보면, nib 파일, 이미지 파일, localized strings, 헤더 파일, 레퍼런스 문서와 같은 공유 리소스들을 하나의 패키지로 묶어놓은 계층적인 폴더라고 애플 문서에는 정의되어 있다.\n라이브러리는 활용가능한 도구들의 집합을 말하는데, 개발자는 라이브러리의 도구를 개발에 이용한다.\nAlamofire나 RxSwift, SwiftyJSON 등도 라이브러리라고 할 수 있겠다.\n프레임워크와 라이브러리의 차이점은 제어의 흐름에 대한 주도권이 누구에게 있는지로 확인할 수 있다. 라이브러리는 개발자가 라이브러리를 호출하여 사용할 수 있는데 반해, 프레임워크는 전체적인 흐름의 주도권을 가지고 있어서 프레임워크가 사용자의 코드를 호출한다고 할 수 있다.\n이것을 제어의 역전(Inversion Of Control)이라고 한다. 🧐 좀더 공부해보자!\niOS 아키텍쳐 이미지 출처: https://www.dotnettricks.com/learn/xamarin/understanding-xamarin-ios-build-native-ios-app iOS 아키텍쳐에서 가장 상위 레벨의 Cocoa Touch 프레임워크를 사용하여 개발을 구현하게 된다. 우리가 가장 많이 사용하는 Foundation, UIKit 프레임워크도 코코아 터치 프레임워크에 속해있다.\nCocoa Touch Foundation 프레임워크는 데이터 저장 및 지속성, 텍스트 처리, 날짜 및 시간 계산, 정렬 및 필터링, 네트워킹을 포함하여 앱 및 프레임워크를 위한 기본 기능 계층을 제공한다.\nUIKit 프레임워크는 iOS 인터페이스 그래픽을 구성하는 도구를 포함하고 이벤트를 처리하는 프레임워크이다.\n인터페이스를 구현하기 위한 창 및 보기 아키텍처, Multi-Touch 및 기타 유형의 입력을 앱에 제공하기 위한 이벤트 처리 인프라, 사용자, 시스템 및 앱 간의 상호 작용을 관리하는 데 필요한 기본 실행 루프를 제공한다.\nReference Apple - What are Frameworks?\nApple - Cocoa\nApple - Foundation\nApple - UIKit\nstackoverflow - What is the difference between a framework and a library?\nFramework vs Library\n소들이 블로그- Cocoa / Cocoa Touch\n","date":"2022-08-28T16:49:28+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/cocoa-touch-framework/","title":"Cocoa Touch Framework"},{"content":"Singleton Singleton이란? Singleton = Only one instance Available (한번만 만들어서 쓴다! 정도랄까?)\n특정 용도로 객체를 하나만 생성하도록 보장하여 사용하는 디자인 패턴\nGangOfFour의 디자인 패턴에서 이야기하고 있는 여러가지 디자인 패턴 중 생성 - Singleton의 UML 다이어그램이다.\n애플 문서의 그림을 보면\n일반적인 Class는 여러번 호출하여 원하는 갯수만큼의 인스턴스를 얻을 수 있지만, 싱글톤 클래스는 애플리케이션이 요청한 횟수와 상관없이 동일한 인스턴스를 반환한다. 싱글톤 개체는 해당 클래스의 리소스에 대한 전역 액세스 지점을 제공(Global available) ➡️ 단점으로는 유닛 테스트가 어려워질 수 있겠다. Cocoa framework에서 UIKit의 NSFileManager, NSWorkspace,\nUIKit에서 UIApplication및 UIAccelerometer가 싱글톤으로 사용된다고 한다.\n싱글톤 인스턴스를 반환하는 팩토리 메서드의 이름은 규칙에 따라 Shared + Class Type 형식\n➡️ Cocoa 프레임워크의 예 sharedFileManager, sharedColorPanel, sharedWorkspace\n🌱 싱글톤 사용 예 1 2 3 4 5 let UserDefaults = UserDefaults.standard let fileManager = FileManager.default let urlSession = URLSession.shared let application = UIApplication.shared let notification = NotificationCenter.default 싱글톤 장/단점 장점 ✅ 한개의 인스턴스만 생성하므로 메모리 낭비를 방지할 수 있음 ✅ Singleton Instance는 전역 Instance로 다른 클래스들과 자원 공유가 쉬움 ✅ 인스턴스가 1개라는 것을 보증받는다 (Thread Safe) 단점 ✅ 인스턴스가 너무 많은 일을 하거나, 많은 데이터를 공유하면 Instance들 간 결합도가 높아져 개방-폐쇄 원칙(OCP, Open-Closed Principle)을 위배할 수 있음(의존성을 만들어 낸다) ➡️ Unit 테스트가 어려워 질 수 있음 Shared Class Type static을 사용하여 싱글톤을 생성할 수 있다\n1 2 3 class Singleton { static let shared = Singleton() } 초기화 이외의 추가 설정을 해야 하는 경우, 클로저 호출 결과를 전역 상수에 할당할 수 있다.\n1 2 3 4 5 6 7 class Singleton { static let shared: Singleton = { let instance = Singleton() // setup code return instance }() } ✅ ochococo 깃허브에 올라와 있는 swift 싱글톤 예제\n1 2 3 4 5 6 7 8 9 final class ElonMusk { static let shared = ElonMusk() private init() {} // Private initialization to ensure just one instance is created. } let elon = ElonMusk.shared // There is only one Elon Musk folks. Reference Apple - Singleton\nManaging a Shared Resource Using a Singleton\nLearn iOS Singletons\nDesign-Patterns-In-Swift - Singleton\n소들이 블로그 - 싱글톤 패턴\n","date":"2022-08-28T14:34:00+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/singleton-pattern/","title":"Singleton Pattern"},{"content":"NameSpace란? 관련 있는 값들을 묶어 놓은 공간을 nameSpace 라고 하는데, swift에서는 namespace를 아직 지원하지 않고 있다. (SwiftUI에서는 nameSpace를 지원하고 있는 듯 하다)\n프로젝트 파일 안에서 사용되고 있는 메시지들을 묶어서 한곳에서 관리하면 나중에 메세지를 변경해야 할 일이 있을 때 일일이 고쳐주지 않고 nameSpace를 수정하고 프로그램 상에서 호출하여 사용하면 유지보수 측면에서 좋을 것 같아 찾아보았다.\n일반적으로 사용되는 방식은 Struct를 사용하거나 Enum을 활용하는 방법으로 해결할 수 있다.\nstruct 구조체를 이용하는 방법 1 2 3 4 5 6 struct GameMessages { private init() {} static let inputWrong: String = \u0026#34;잘못된 입력입니다. 다시 시도해주세요.\u0026#34; static let endGame: String = \u0026#34;게임종료\u0026#34; static let victory: String = \u0026#34;의 승리!\u0026#34; } 프로그램 안에서 사용되는 텍스트를 묶어서 GameMessages라는 구조체를 만들어 주고 static 키워드를 이용하여 타입 프로퍼티로 생성해 주었다.\n사용할 때에는\n1 2 let wrongInput = GameMessages.inputwrong let gameFinish = GameMessages.endGame 으로 선언하여 사용한다.\nstruct로 nameSpace를 사용할 때의 문제점은 다른 개발자가 실수로 인스턴스를 생성할 수 있다는 점이다. 인스턴스 생성을 막기 위해 private init() {}을 써주어서 인스턴스화 할 수 없도록 만들어준다.\nenum 열거형을 이용하는 방법 다른 방법으로는 enum을 이용하여 nameSpace를 설정해주는 방법이다.\ncase를 설정하지 않고 enum을 만들 수 있나요? 네! 방법이 있습니다.\n1 2 3 4 5 enum GameMessages { static let inputWrong: String = \u0026#34;잘못된 입력입니다. 다시 시도해주세요.\u0026#34; static let endGame: String = \u0026#34;게임종료\u0026#34; static let victory: String = \u0026#34;의 승리!\u0026#34; } case가 없는 열거형을 사용하면 실수로 인스턴스화를 할 수 없고 nameSpace의 역할을 할 수 있도록 설정가능하다.\n유지보수의 측면에서는 한 곳에서 여러개의 리터럴을 관리하고 수정할 수 있어서 nameSpace를 사용하는 편이 좋겠지만, 메모리 측면에서는 프로그램이 실행되면 모든 static 상수가 메모리에 탑재되므로 메모리 관리 측면에서는 좋은 방법이 아닐 수도 있다는 생각이 들었다.\nReference nameSpace\nhttps://cocoacasts.com/namespaces-in-swift\nhttps://onelife2live.tistory.com/15\nhttps://sujinnaljin.medium.com/namespace-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0-struct-vs-enum-ce86d5717d95\nhttps://zeddios.tistory.com/353\nType property(static)\nhttps://varyeun.tistory.com/entry/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8%EC%97%90%EC%84%9C-static-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%9E%80-static-in-swift\n","date":"2022-08-27T15:01:23+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/swift%EC%97%90%EC%84%9C%EC%9D%98-namespace/","title":"Swift에서의 nameSpace"},{"content":"다른 조원 분의 프로젝트를 보다가 @discardableResult를 사용한 부분을 보게되었다.\n오늘은 @discardableResult에 대해서 알아보자.\n버릴 수 있는 결과 정도로 해석할 수 있는 @discardableResult\n공식문에서는 이렇게 정의하고 있다.\n\u0026ldquo;결과를 사용하지 않고 값을 반환하는 함수 또는 메서드가 호출될 때 컴파일러 경고를 표시하지 않으려면 이 특성을 함수 또는 메서드 선언에 적용합니다.\u0026rdquo;\nAttributes 페이지 상단에 있는 예제를 살펴보면\nthe discardableResult attribute on a function declaration indicates that, although the function returns a value, the compiler shouldn’t generate a warning if the return value is unused.\ndiscardableResult함수 선언의 속성은 함수가 값을 반환하더라도 반환 값이 사용되지 않는 경우 컴파일러에서 경고를 생성하지 않아야 함을 나타냅니다.\n예제를 살펴보면\n2개의 Int를 받아 합계를 리턴하는 함수 sum을 만들고 호출해보면 Xcode에서 Result of call to 'sum(a: b:)' is unused라는 경고를 보여준다. 리턴되는 값을 사용하지 않아 경고를 보여주는 것인데,\n이럴 때 @discardableResult를 앞에 붙여주면 경고를 무시하고 사용할 수 있다.\nReference Swift Docs - Attributes\n","date":"2022-08-26T14:29:32+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/attributes-discardableresult%EB%9E%80/","title":"Attributes - @discardableResult란?"},{"content":"범위 연산자 ~= (Range Operators) 오늘은 범위 연산자 ~=에 대해 알아보자.\n공식문서에서는 pattern과 value라고 써있어서 살짝 헷갈리는데, 오른쪽의 value값이 왼쪽의 pattern Range 범위에 있는지 확인하고 Bool 값을 리턴한다.\n1 2 3 4 5 let chosenNumber = 3 if 0..\u0026lt;10 ~= chosenNumber { print(\u0026#34;\\(chosenNumber) is a single digit.\u0026#34;) } // Prints \u0026#34;3 is a single digit.\u0026#34; 문자열에 사용할 수도 있다. 사용자 입력을 받거나 주어진 String에 소문자를 포함하고 있는지 확인하는 함수이다.\n1 2 3 4 5 6 7 8 9 func checkLowercase(of input: String) -\u0026gt; Bool { if \u0026#34;a\u0026#34;...\u0026#34;z\u0026#34; ~= input { print(\u0026#34;소문자를 포함하고 있습니다.\u0026#34;) return true } else { print(\u0026#34;소문자를 포함하지 않고 있습니다.\u0026#34;) return false } } 팀원과 시간 맞추어 프로젝트도 해야하고.. 이래저래 바쁘다고 느끼지만, 공부하지 않으면 계속해서 기술부채 (Technical debt) 가 쌓인다.\n📖 공부하자! 공부!\nReference Swift Doc - ~=(_:_:\n","date":"2022-08-24T07:44:00+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90/","title":"범위 연산자"},{"content":"오늘은 스위프트에서 유저인풋을 받을 때 사용하는 readLine()에 대해 알아보자.\n현재의 라인 혹은 EOF(End Of File) 까지의 표준입력을 받아 Optional String타입으로 반환하는 함수이다. 엔터가 입력될때까지 라고 이해하면 되겠다.\n공백 단위로 입력받기 split 1 func split(separator: Character, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -\u0026gt; [Substring] 공백을 제거하고 입력받기 위해서는 split()함수를 이용하면 된다. [SubString] 타입으로 반환된다.\nseparator ➡️ 쪼개려는 문자 단위 \u0026quot; \u0026ldquo;(공백), \u0026ldquo;/\u0026rdquo;, etc maxSplits ➡️ 지정한 문자 단위로 몇번까지 쪼갤지를 설정할 수 있다. omittingEmptySubsequences ➡️ 비어있는 시퀀스 포함 유무 설정 1 2 3 4 5 6 if let input = readLine()?.split(seperator: \u0026#34; \u0026#34;) { print(input) } // \u0026#34;a b c\u0026#34; 입력 시 \u0026#34; \u0026#34;(공백)기준으로 잘라서 배열로 저장한다. // [\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;] components components(separatedBy: )를 사용할 수도 있다.\nsplit과의 차이점은 Foundation 프레임워크가 정의되어 있어야 사용이 가능하고, 리턴값은 [String]\n1 2 3 4 5 6 if let input = readLine()?.components(separatedBy: \u0026#34; \u0026#34;) { print(input) } // \u0026#34;a b c\u0026#34; 입력 시 \u0026#34; \u0026#34;(공백)기준으로 잘라서 배열로 저장한다. [\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;] 두줄 입력 한꺼번에 받기 1 2 3 4 5 6 7 8 9 10 11 12 print(\u0026#34;please input your firstName : \u0026#34;, terminator: \u0026#34;\u0026#34;) if let firstName = readLine() { print(\u0026#34;please input your lastName : \u0026#34;, terminator: \u0026#34;\u0026#34;) if let lastName = readLine() { print(firstName, lastName) } } // please input your firstName : Jae // please input your lastName : Kim // Jae Kim Reference Swift Doc - readLine\n","date":"2022-08-20T21:02:43+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/readline-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/","title":"readLine() 알아보기"},{"content":" 1 Int == Optional(Int) ❓❓❓ 이게 가능하다고! 오늘은 우리가 자주 사용하는 == 오퍼레이터에 대해 알아보자\n공식문서에서는 이렇게 Equal to를 정의하고 있다.\n1 static func == (lhs: Wrapped?, rhs: Wrapped?) -\u0026gt; Bool 왼쪽과 오른쪽의 옵셔널 타입을 비교하여 같은지를 Bool 값으로 반환한다.\nYou can also use this operator to compare a non-optional value to an optional that wraps the same type. The non-optional value is wrapped as an optional before the comparison is made.\nIn the following example, the numberToMatch constant is wrapped as an optional before comparing to the optional numberFromString:\nnon-optional Type인 경우 비교되기 전에 랩핑하여 비교하기 때문에 비교가 가능하다!\n1 2 3 4 5 6 let numberToFind: Int = 23 let numberFromString: Int? = Int(\u0026#34;23\u0026#34;) // Optional(23) if numberToFind == numberFromString { print(\u0026#34;It\u0026#39;s a match!\u0026#34;) } // Prints \u0026#34;It\u0026#39;s a match!\u0026#34; Reference Swift Doc - ==(_:_:)\n","date":"2022-08-20T20:05:22+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/equal-to-operator/","title":"== Equal to Operator"},{"content":"개요 Mac OS Sierra 이후 버전에서는 한글 키보드인 경우 숫자키 1번 왼쪽의 백틱 (`) 키를 눌렀을 때 원화 표시(₩)가 입력된다.\n깃허브 README나 기술블로그에서 마크다운 문법을 많이 사용하는 사람에게는 매번 한/영 전환을 해야 하니 여간 불편한 일이 아닐 수 없다.\n해결방법 1 - Option 키 함께 사용 한글자판일 때 Option 과 백틱 키를 함께 누르면 ₩ 대신 `키를 입력할 수 있다.\n해결방법 2 - 라이브러리 파일 추가 ~/Library 폴더로 이동한 후, KeyBindings 폴더로 이동한다. 혹시 없다면 KeyBindings 폴더를 생성한다.\nOption키를 누른 상태에서 Finder-이동 메뉴로 이동하면 \u0026ldquo;라이브러리\u0026quot;가 보이고 클릭 시 라이브러리 폴더로 이동할 수 있다.\n~/Library/KeyBindings 폴더 내부에 DefaultkeyBinding.dict 파일을 생성한다.\n$ touch DefaultkeyBinding.dict ➡️ 이미 파일이 있는 사람은 생략\nDefaultkeyBinding.dict 파일을 텍스트 편집기로 열어 아래 내용을 추가하고 저장한다.\n이렇게 하면 한글 상태일 때도 `이 바로 입력되고, ₩ 키를 사용하고 싶다면 Option키를 누르면 ₩도 사용할 수 있다.\n1 2 3 4 { \u0026#34;₩\u0026#34; = (\u0026#34;insertText:\u0026#34;, \u0026#34;`\u0026#34;); \u0026#34;~₩\u0026#34; = (\u0026#34;insertText:\u0026#34;, \u0026#34;₩\u0026#34;); } 해결방법 3 - 쉘 스크립트 사용 터미널을 열고 아래 코드를 복사해서 붙여넣고 엔터를 치면 바로 설정이 저장된다.\n1 curl -sSL https://gist.githubusercontent.com/JaeKimdev/c4bce47b5282d81ca9b5f29544361825/raw/4015ea66f49ed749b58b9cd2a1514d49326fcfc5/wontobacktick.sh | sh 적용 / 해제 저장한 후 맥을 재부팅하면 적용된다.\n다시 되돌리고 싶을 때는 DefaultkeyBinding.dict 을 삭제해 주면 된다.\n","date":"2022-08-11T22:21:57+08:00","image":"https://JaeKimdev.github.io/post/tech/220811-1.webp","permalink":"https://JaeKimdev.github.io/p/%EB%A7%A5%EC%97%90%EC%84%9C-%ED%82%A4-%EB%8C%80%EC%8B%A0-backtick%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/","title":"맥에서 ₩ 키 대신 Backtick(`)을 입력하는 방법"},{"content":"Collection Type을 돌릴 때 사용하는 for in과 고차함수 .forEach에 대해 알아보자.\nfor-in ❓ forEach for - in You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.\n스위프트 문서에서는 for - in loop를 사용해서 배열의 아이템, 숫자 범위, 문자열에서의 문자와 같은 시퀀스를 반복할 수 있다고 기술되어 있다.\nforEach(_:) Calls the given closure on each element in the sequence in the same order as a for-in loop.\nfor in loop와 동일한 순서로 시퀀스의 각 요소에 주어진 클로저를 호출한다고 기술되어 있다.\n각각의 예제 예제 1 - 각각의 요소 출력 1 2 3 4 5 6 7 8 9 let numbers = [1, 2, 3, 4, 5] for number in numbers { print(number) // 1 2 3 4 5 } numbers.forEach { print($0) // 1 2 3 4 5 } 예제 2 - 인덱스와 값 동시 출력 for-in loop 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let numbers = [1, 2, 3, 4, 5] // enumerated 사용 for (index, number) in numbers.enumerated() { print(\u0026#34;index: \\(index) number: \\(number)\u0026#34;) } // indices 사용 for index in numbers.indices { print(\u0026#34;index: \\(index) number: \\(numbers[index])\u0026#34;) } // 반복횟수 지정 for index in 0..\u0026lt;numbers.count { print(\u0026#34;index: \\(index) number: \\(numbers[index])\u0026#34;) } 3가지 방법 모두 같은 결과를 출력한다. forEach 사용 1 2 3 4 5 6 7 8 9 let numbers = [1, 2, 3, 4, 5] numbers.enumerated().forEach { print(\u0026#34;(index: \\($0) num: \\($1))\u0026#34;) } numbers.indices.forEach { print(\u0026#34;(index: \\($0) num: \\(numbers[$0]))\u0026#34;) } for-in과 마찬가지로 enumerated, indices을 사용하면 된다. ❗️ for-in 의 경우 반복횟수를 지정하여 사용할 수 있었지만, forEach의 경우 각 요소에 주어진 클로저를 호출하는 것이기 때문에 따로 반복횟수를 지정할 수 없고 요소의 개수만큼만 반복할 수 있다.\n예제 3 - break / continue 사용 for-in loop 사용 1 2 3 4 5 6 7 8 9 10 let numbers = [1, 2, 3, 4, 5] for number in numbers { if number == 3 { break } print(number) } // 1 // 2 forEach 사용 break와 continue는 loop와 switch안에서만 사용 가능하다는 오류메세지가 보여짐\nforEach에서는 사용 불가\n예제 4 - return for-in loop 사용 1 2 3 4 5 6 7 8 9 10 11 let numbers = [1, 2, 3] func printForIn() { for number in numbers { print(number) return } } printForIn() // 1 반복문을 돌다가 return을 만나면 함수가 종료됨.\nforEach 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 let numbers = [1, 2, 3] func printForIn() { numbers.forEach { print($0) return } } printForIn() // 1 // 2 // 3 forEach는 클로저를 요소 갯수만큼 실행하기 때문에 return을 만나도 전달했던 클로저를 종료하고 다음 요소의 클로저 호출에는 영향을 주지 않는다.\nReference https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html\nhttps://developer.apple.com/documentation/swift/array/foreach(_:)\nhttps://babbab2.tistory.com/95?category=828998\nhttps://velog.io/@un1945/Swift-for-in-forEach-%EC%B0%A8%EC%9D%B4%EC%A0%90\n","date":"2022-08-10T11:17:56+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/for-in-/-foreach-%EB%B9%84%EA%B5%90/","title":"for - in / forEach 비교"},{"content":"배열 생성하기 1 2 3 4 5 6 7 8 9 10 11 12 13 let emptyArray: [Int] = [1, 2, 3] let emptyArray1: [Int] = [] // 빈 배열 생성 let emptyArray2 = Array\u0026lt;Int\u0026gt;() let emptyArray3 = [Int]() let anyArray = [Any] = [1, 2, \u0026#34;three\u0026#34;, 4.0] // Any 타입으로 여러 자료형을 묶을 수도 있다. let nums = Array(1...3) // [1, 2, 3] // 범위 연산자 사용 가능 // (repeating: 배열의 타입과 일치하는 값(1개), count: 값을 반복할 횟수) let emptyArray4 = [Int](repeating: 0, count: 10) // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 배열 갯수 확인 1 2 3 4 5 var numbers = [1, 2, 3] let count: Int = numbers.count // 배열 갯수 확인 : 3 let isEmpty: Bool = numbers.isEmpty // 배열이 비어있는지 확인 : false // numbers.count == 0 을 사용할 수도 있지만 numbers.isEmpty도 가능 배열 요소 접근 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var emptyArray: [Int] = [] var numbers = [1, 2, 3] // Subscript로 접근 numbers[0] // 1 numbers[1] // 2 // 범위로 접근 numbers[0...1] // [1, 2] // 속성으로 접근 numbers.first // Optional(1) numbers.last // Optional(3) emptyArray.first // nil - 배열이 비어있다면 nil을 반환 numbers[numbers.startIndex] // 1 numbers[numbers.endIndex] // error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0). // endIndex는 배열의 마지막 인덱스가 아님!! numbers[numbers.index(before: numbers.endIndex)] // 3 ❓ endIndex\nThe array’s “past the end” position—that is, the position one greater than the last valid subscript argument.\n공식문서에서는 endIndex를 배열의 끝을 지난 인자 라고 정의하고 있다;\n1 2 3 4 5 var numbers = [10, 20, 30, 40, 50] if let i = numbers.firstIndex(of: 30) { print(numbers[i ..\u0026lt; numbers.endIndex]) } // Prints \u0026#34;[30, 40, 50]\u0026#34; 배열에 요소 추가하기(append, insert) 1 2 3 4 5 6 7 // 1. append : 배열 끝에 추가 numbers.append(4) // [1, 2, 3, 4] numbers.append(contentsOf: [5, 6]) // [1, 2, 3, 4, 5, 6] // 2. insert : 중간에 추가 numbers.insert(0, at: 0) // [0, 1, 2, 3, 4, 5, 6] numbers.insert(contentsOf: [10, 100], at: 2) // [0, 1, 10, 100, 2, 3, 4, 5, 6] insert를 사용하는 경우 배열을 재배치 해야 하기 때문에 오버헤드가 발생한다.\n배열 요소 삭제하기(remove) 1 2 3 4 5 6 7 8 9 var array1 = [1, 2, 3, 4, 5, 6, 7, 8, 9] array1.remove(at: 2) // [1, 2, 4, 5, 6, 7, 8, 9] array1.removeFirst() // [2, 4, 5, 6, 7, 8, 9] array1.removeFirst(2) // [5, 6, 7, 8, 9] array1.removeLast() // [5, 6, 7, 8]\u0026amp; array1.popLast() // [5, 6, 7] array1.removeLast(2) // [5] array1.removeAll() // [] 함수 이름 용도 리턴 타입 remove(at:) 파라미터로 받은 index에 해당하는 값 삭제 삭제된 값 리턴, Non-Optional Type removeFirst 첫 번째 요소 삭제 삭제된 값 리턴, Non-Optional Type removeFirst(_:) 첫 번째 요소부터 파라미터로 받은 갯수 만큼 삭제 X removeLast 마지막 요소 삭제 삭제된 값 리턴 , Non-Optional Type popLast 마지막 요소 삭제 삭제된 값 리턴, Optional Type removeLast(_:) 마지막 요소부터 파라미터로 받은 갯수 만큼 삭제 X removeAll 전체 요소 삭제 X 특정 범위 삭제하기\n1 2 3 4 var array2 = [1, 2, 3, 4, 5, 6, 7, 8, 9] array2.removeSubrange(1...3) // [1, 5, 6, 7, 8, 9] array2[0..\u0026lt;2] = [] // [6, 7, 8, 9] 함수 이름 용도 리턴 타입 removeSubrange(_:) 파라미터로 받은 범위만큼 index 요소 삭제 X [n...m] = [] Subscript 문법으로 n ~ m까지 index 요소 삭제 X 배열 비교하기(elementsEqual) 1 2 3 4 5 6 var array1 = [1, 2, 3] var array2 = [1, 2, 3] var array3 = [1, 2, 3, 4, 5,] array1 == array2 //true array1.elementsEqual(array3) //false elementsEqual은 모든 요소가 똑같아야 true를 리턴한다.\n배열 요소 검색(contains) contains(_:)을 사용하여 특정 값이 포함되어 있는지를 확인할 수 있다. Bool 타입으로 알려준다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let numbers = Array(1...10) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] numbers.contains(1) // true numbers.contains { number in number % 2 == 0 // true - 짝수가 하나라도 있으면 true } numbers.first { // 클로저 조건을 만족하는 첫번째 `값`을 리턴, 없으면 nil bnumber in number % 2 == 0 // Optional(2) } numbers.firstIndex { // 클로저 조건을 만족하는 첫번째 `인덱스`를 리턴, 없으면 nil number in number % 2 == 0 // Optional(1) } 배열 정렬하기 (sort, sorted) 1 2 3 4 5 6 7 8 9 var numbers = [1, 5, 3, 8, 6, 10, 14] // sort - 배열을 직접 정렬 numbers.sort() // [1, 3, 5, 6, 8, 10, 14] 오름차순 numbers.sort(by: \u0026gt;) // [14, 10, 8, 6, 5, 3, 1] 내림차순 //sorted - 원본은 그대로 두고, 새로우누 배열을 만들어 리턴 let sortedArray = numbers.sorted() // [1, 3, 5, 6, 8, 10, 14] 오름차순 let sortedArray2 = numbers.sorted(by: \u0026gt;) // [14, 10, 8, 6, 5, 3, 1] 내림차순 배열 요소 섞기(shuffle, shuffled) 1 2 3 4 5 var numbers = [1, 2, 3, 4, 5] numbers.shuffle() // [4, 1, 5, 3, 2] let shuffleNumbers = numbers.shuffled() // [5, 2, 1, 3, 4] 배열 요소 위치 바꾸기(swapAt) 1 2 var numbers = [1, 2, 3, 4, 5] numbers.swapAt(0, 4) // 0과 4 인덱스 변경 [5, 2, 3, 4, 1] 함수 이름 참고사항 (-ed, -ing) Swift에서 보통 함수 이름에 -ed, -ing가 붙는 것들은 원본은 그대로 두고, 새로운 것을 리턴함!\nReference https://developer.apple.com/documentation/swift/array\nhttps://developer.apple.com/documentation/swift/array/endindex\nhttps://developer.apple.com/documentation/swift/array/shuffle()\nhttps://developer.apple.com/documentation/swift/string/shuffled()\nhttps://axe-num1.tistory.com/19\nhttps://soooprmx.com/swift-array-01-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%A1%B0%EC%9E%91/\nhttps://babbab2.tistory.com/92?category=828998\n","date":"2022-08-09T21:01:24+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/array%EC%99%80-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C/","title":"Array와 자주 사용하는 메서드"},{"content":"📖 intro github에 공부한 것을 계속 올리고는 있지만, 협업으로서 git을 사용해 본 적은 아직 없고, yagom Swift Code Start Camp에서도 git을 잘 사용하지 않고 XCode에서 commit, push를 하여 프로젝트를 진행했었다.\nCareer Starter Camp 사전 과제할 때 처음부터 끝까지 git으로 진행을 했었지만 확실하게 개념을 알고 있다는 생각이 들진 않아서 git을 공부해보기로 했다.\n이전에 결제해 놓은 드림코더 엘리님의 git 강의와 북마크 해놓았던 알잘딱깔센(?) - 알아서 잘 딱 깔끔하고 센스있게 정리하는 GitHub 핵심 개념 페이지를 활용하기로 했다.\n이곳에서 pdf 강의 자료도 다운받을 수 있다.\n📚 자주 쓰는 git 명령어 강의 자료에서 이 그림이 제일 신선하고 재미있었다~ :D\ngit pull로 땡겨와서 git add .명령으로 stage에 올리고 commit한 후에 push\n어때요? 참 쉽죠? https://learngitbranching.js.org/ 여기에서 연습해보는 것도 좋다.\nReference 알잘딱깔센 Github - 강의자료\nGit Cheat Sheet\n","date":"2022-08-08T22:17:43+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1659968513/github_tdiagh.jpg","permalink":"https://JaeKimdev.github.io/p/git-%EC%A0%95%EB%A6%AC/","title":"git 정리"},{"content":"COW 🐂 ❓ COW(Copy On Write)는 Swift에서 성능향상을 위해 사용되는 방법이다.\nSwift에서 Array 복사를 할 때 실제로 값을 복사하지 않고 원본 리소스를 공유하다가 원본이나 복사본에 수정이 일어나는 경우 그 때 복사가 이루어지도록 하는 것을 COW 라고 한다.\n주소값을 프린트하는 address()함수를 만들고 array1 배열을 복사하여 array2에 할당하고 주소를 찍어보면 동일한 주소를 가리키고 있는 것을 볼 수 있다.\narray2에 숫자를 추가하고 주소를 찍어보면 array2의 주소가 변경된 것을 확인 할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func address(of: UnsafeRawPointer) { let address = String(format: \u0026#34;%p\u0026#34;, Int(bitPattern: of)) print(address) } var array1 = [1,2,3,4] var array2 = array1 address(of: array1) // 0x60000231a5e0 address(of: array2) // 0x60000231a5e0 //change array 2 array2.append(7) address(of: array1) // 0x60000231a5e0 address(of: array2) // 0x6000019ecb60 복사한 내용이 동일하다면 메모리를 추가로 사용하지 않고 참조함으로써 불필요한 메모리 사용을 방지하고 효율적으로 성능향상을 할 수 있다.\n물론 첫번째 수정이 이루어지는 시점에 값을 복사하기 때문에 시간이 조금 더 걸릴 수 있지만, 동일한 내용의 경우 복사하지 않기 때문에 속도나 메모리 관리 측면에서 잃는 것보다 얻는 것이 많다고 해야 할까..\nReference https://medium.com/@lucianoalmeida1/understanding-swift-copy-on-write-mechanisms-52ac31d68f2f\nhttps://ishtiz.com/swift/what-is-copy-on-writecow-in-swift\nhttps://babbab2.tistory.com/18\n","date":"2022-08-07T17:06:10+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/cowcopy-on-write/","title":"COW(Copy-On-Write)"},{"content":"Tuple ❓ \u0026ldquo;A tuple type is a comma-separated list of types, enclosed in parentheses.\u0026rdquo;\n스위프트 문서에는 \u0026ldquo;콤마로 구분된 타입의 목록으로 괄호로 묶여있다\u0026rdquo; 라고 정의되어 있다.\n배열(Array)와 다른 점은 같은 배열은 같은 타입의 데이터를 담을 수 있지만 Tuple은 타입이 같지 않아도 사용가능하다는 점이 다르다.\nDeclaration 1 2 3 4 5 6 var 변수명: (데이터 타입 1, 데이터 타입 2, 데이터 타입 3) = (값1, 값2, 값3) // 으로 선언한다. // 타입 추론이 가능하므로 데이터 타입을 생략하고 var 변수명 = (값 1, 값 2, 값 3) //으로 사용도 가능하다. Usage tuple 사용은 변수명 뒤에 .을 붙여서 호출한다.\n1 2 3 4 5 var jae = (\u0026#34;Jae\u0026#34;, 20, 176.5) print(jae.0) // Jae print(jae.1) // 20 print(jae.2) // 176.5 인덱스 넘버를 사용하는 경우 어떤 데이터를 호출하는지 알기 어렵기 때문에 튜플을 선언할 때 이름을 붙여주면 좋다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var jenny = (name: \u0026#34;Jenny\u0026#34;, age: 21, height: 169.7) print(jenny.name) // Jenny print(jenny.age) // 21 print(jenny.height) // 169.7 // Array와 마찬가지로 tuple안에 tuple을 넣어줄 수 있다. var tuple = (1, \u0026#34;Hello, world!\u0026#34;, true) var anotherTuple = (2, (tuple)) print(anotherTuple.0) // 1 print(anotherTuple.1.0) // 2 print(anotherTuple.1.1) // Hello, world! print(anotherTuple.1.2) // true // 함수 타입도 가능 func a() -\u0026gt; Int { return 1 } func b() -\u0026gt; String { return \u0026#34;Jae\u0026#34; } func c() -\u0026gt; Bool { return false } var functionTuple = (a(), b(), c()) print(functionTuple) // (1, \u0026#34;Jae\u0026#34;, false) loop 사용 배열처럼 인덱스가 있으니 tuple에서도 loop를 돌려서 값을 출력할 수 있을까?\nFor-in loop requires '(name: String, age: Int, height: Double)' to conform to 'Sequence' 라고 에러메세지 출력!\ntuple은 Sequence 프로토콜을 준수하고 있지 않기 때문에 사용할 수 없다. 😭\nSequence 프로토콜을 따르고 있는 Array 안에 넣어준다면? loop를 돌릴 수 있다!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let jae = (name: \u0026#34;Jae\u0026#34;, age: 20, height: 176.5) let jenny = (name: \u0026#34;Jenny\u0026#34;, age: 21, height: 169.7) let people = [jae, jenny] for person in people { print(person) // (name: \u0026#34;Jae\u0026#34;, age: 20, height: 176.5) // (name: \u0026#34;Jenny\u0026#34;, age: 21, height: 169.7) print(person.name) // 이름 사용도 가능하다 // Jae // Jenny } Tuple Decomposition 🔪 1 2 3 4 5 6 7 8 9 10 11 12 let jae = (name: \u0026#34;Jae\u0026#34;, age: 20, height: 176.5) // 각각의 멤버를 상수로 저장하고 싶다면 let name = jae.name let age = jae.age let height = jae.height // Decomposition 문법을 사용하면 한줄로 가능하다 let (nameOfJae, ageOfJae, heightOfJae) = jae print(name) // Jae print(nameOfJae) // Jae Decomposition 문법 사용 시, 주의할 점은 모든 멤버를 다 지정해주어야 한다는 점이다.\n모든 멤버가 다 필요하지 않다면, wildcard(_)를 사용하면 된다.\n1 2 3 4 5 6 let jae = (name: \u0026#34;Jae\u0026#34;, age: 20, height: 176.5) let (name, _, height) = jae print(name) // Jae print(height) // 176.5 typealias 사용 tuple은 typealias을 사용하여 타입으로 지정할 수도 있다. 이렇게 타입으로 지정해주면 다른 값을 넣어 선언할 수 없고, tuple 타입의 배열도 만들 수 있다.\n1 2 3 4 5 6 typealias Person = (name: String, age: Int, height: Double) let jae: Person = (name: \u0026#34;Jae\u0026#34;, age: 20, height: 176.5) let jenny: Person = (name: \u0026#34;Jenny\u0026#34;, age: 21, height: 169.7) let People = [Person]() Tuple Matching - switch 사용 튜플은 switch와 함께 사용하여 조건을 줄 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let name = (firstname:\u0026#34;Jae\u0026#34;, lastname:\u0026#34;Kim\u0026#34;) switch name { case let(first, last) where first == last: print(\u0026#34;Hello \\(first) \\(last)! That\u0026#39;s indeed an interesting name\u0026#34;) case let(_, last) where last == \u0026#34;\u0026#34;: print(\u0026#34;Hello \\(name.firstname), Why didn\u0026#39;t you share you surname?\u0026#34;) case let(first, _) where first == \u0026#34;\u0026#34;: print(\u0026#34;Hello \\(name.lastname)! You didn\u0026#39;t share your first name\u0026#34;) default: print(\u0026#34;Hello \\(name.firstname) \\(name.lastname)!, nice to meet you!\u0026#34;) } // Hello Jae Kim!, nice to meet you! Reference Swift Doc - tuple type\nZedd0202 - Swift) tuple\nSwift) 튜플(Tuple)에 대해 알아보자\n","date":"2022-08-05T11:15:27+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/tuple-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/","title":"Tuple 알아보기"},{"content":"Assertion assert(_:_:file:line:) 함수를 사용한다.\nassert 함수는 디버깅 모드에서만 동작하고 배포하는 어플리케이션에서는 제외된다. 조건 체크, 테스트 등에 사용한다.\nDeclaration 총 4개의 인자를 받을 수 있다.\n체크할 조건문 / 조건 미충족 시 발생하는 오류 메시지 / 메세지를 출력할 파일 / 출력할 메세지 라인 수\n1 2 3 4 5 6 func assert( _ condition: @autoclosure () -\u0026gt; Bool, _ message: @autoclosure () -\u0026gt; String = String(), file: StaticString = #file, line: UInt = #line ) 📖 Parameters\n- condition The condition to test. condition is only evaluated in playgrounds and -Onone builds. - message A string to print if condition is evaluated to false. The default is an empty string. - file The file name to print with message if the assertion fails. The default is the file where assert(_:_:file:line:) is called. - line The line number to print along with message if the assertion fails. The default is the line number where assert(_:_:file:line:) is called. Usage 1 2 3 4 5 6 var someInt: Int = 0 assert(someInt == 0, \u0026#34;someInt != 0\u0026#34;) someInt = 1 assert(someInt == 0, \u0026#34;someInt != 0\u0026#34;) // main.swift:15: Assertion failed: someInt != 0 Reference Apple Developer - assert\nyagom youtube - assert와 guard\n","date":"2022-08-03T10:05:27+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/assert-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/","title":"assert 알아보기"},{"content":"hugo 테마 변경 - stack Clien에서 hugo 검색중에 냉동코더님의 기술블로그를 보게 되었다. 흰색 화면이 뿜어내는 밝은 빛에 눈이 아프던 차에, 하단에 보이는 Dark Mode 버튼이 어찌나 반갑던지..\n또 자동으로 우측에 ## 헤더를 인식하여 Table of contents도 만들어준다.\n그리하여 시작된 테마 변경하기!\n‼️ 일단 blog 폴더 백업은 필수 !!!\n여러번의 시행착오 끝에, 그냥 blog 폴더를 날려버리고 다시 처음부터 이전 포스트를 참고하여 진행했다.\n서브 모듈을 add 할때 git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack 이렇게 입력해 주고 stack theme폴더에서 config.yaml을 루트로 이동하여 설정해 주었다.\n백업해 두었던 content/post 폴더를 복사해서 붙여넣기 해 주면 데이터 이전 완료!\nReference CaiJimmy/hugo-theme-stack 냉동코더님 블로그 How to switch to another Hugo theme 3단계. config.toml 설정하기 GoogleAnalytics 4 휴고 블로그에 적용 시키기 ","date":"2022-08-02T09:25:10+08:00","image":"https://cdn.clien.net/web/api/file/F01/8800574/2dab9ea4a96910.jpg?w=780\u0026h=30000","permalink":"https://JaeKimdev.github.io/p/hugo-%ED%85%8C%EB%A7%88-stack%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/","title":"hugo 테마 stack으로 변경하기 "},{"content":"Enumerations 열거형 Enum은 관련있는 값을 모아놓은 Type의 일종이다.\n제한된 선택지를 제공하여 원치 않는 값이 잘못 입력되지 않도록 하고, 특정 값 중에서 하나만 선택할 수 있도록 한다.\nEnumeration Syntax 1 2 3 4 5 6 7 8 9 10 11 12 enum TypeName { case caseName1 case caseName2 case caseName3 ... } // 혹은 하나의 case문에 한줄로 나열하는 것도 가능하다. enum TypeName { case caseName1, caseName2, caseName3, ... } Enum의 사용 1 2 3 4 5 6 7 8 9 10 11 12 enum CompassPoint { // Compass라는 타입을 열거형으로 선언. Enum은 대문자로 시작한다. case North case South case East case West } var directionToHead = CompassPoint.West //same as above var directionToHead: CompassPoint = .West directionToHead = .East 열거형과 Switch 열거형은 switch문과 함께 자주 사용된다고 한다. 모든 case를 포함한다면 default문을 사용할 필요가 없다.\n1 2 3 4 5 6 7 8 9 10 11 12 directionToHead = .South switch directionToHead { case .North: print(\u0026#34;Lots of planets have a north\u0026#34;) case .South: print(\u0026#34;Watch out for penguins\u0026#34;) case .East: print(\u0026#34;Where the sun rises\u0026#34;) case .West: print(\u0026#34;Where the skies are blue\u0026#34;) } // Prints \u0026#34;Watch out for penguins\u0026#34; 1 2 3 4 5 6 7 directionToHead = .South switch directionToHead { case .North: print(\u0026#34;Lots of planets have a north\u0026#34;) case default: print(\u0026#34;I don\u0026#39;t know much about this direction\u0026#34;) } Raw Value 원시 값 각각의 Enum에 값을 할당해 줄 수 있다. 이것을 원시 값이라고 한다.\n원시 값 사용은 .rawValue를 사용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 enum Weekday { case Monday = \u0026#34;월요일\u0026#34; case Tuesday = \u0026#34;화요일\u0026#34; case Wednesday = \u0026#34;수요일\u0026#34; case Thursday = \u0026#34;목요일\u0026#34; case Friday = \u0026#34;금요일\u0026#34; case Saturday = \u0026#34;토요일\u0026#34; case Sunday = \u0026#34;일요일\u0026#34; } print(Weekday.Monday) // Monday print(Weekday.Monday.rawValue) // 월요일 인스턴스 프로퍼티, 메소드 사용 📖 rawValue를 정수값으로 선언하고, name은 인스턴스 프로퍼티로 구현할 수도 있다.\n원시값이 정수인 경우 가장 먼저 선언된 case부터 1씩 증가된 값이 들어간다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 enum Weekday: Int { case Monday = 1 case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday var name: String { switch self { case .Monday: return \u0026#34;월요일\u0026#34; case .Tuesday: return \u0026#34;화요일\u0026#34; case .Wednesday: return \u0026#34;수요일\u0026#34; case .Thursday: return \u0026#34;목요일\u0026#34; case .Friday: return \u0026#34;금요일\u0026#34; case .Saturday: return \u0026#34;토요일\u0026#34; case .Sunday: return \u0026#34;일요일\u0026#34; } } } print(Weekday.Monday) // Monday print(Weekday.Sunday.rawValue) // 7 print(Weekday.Monday.name) // 월요일 📖 메소드로도 구현할 수 있다. 호출은 name()을 사용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 enum Weekday: Int { case Monday = 1 case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday func name() -\u0026gt; String { switch self { case .Monday, .Tuesday, .Wednesday, .Thursday, .Friday: return \u0026#34;Weekday\u0026#34; case .Saturday, .Sunday: return \u0026#34;Weekends\u0026#34; } } } print(Weekday.Monday) // Monday print(Weekday.Sunday.rawValue) // 7 print(Weekday.Monday.name()) // Weekday print(Weekday.Monday.name) // (Function) CaseIterable 프로토콜 - 모든 값 꺼내기 Enum에서도 프로토콜을 채택할 수 있고, CaseIterable의 allCases를 사용하여 모든 값을 꺼낼 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 enum Weekday: CaseIterable { case Monday case Tuesday case Wednesday case Thursday case Friday case Saturday case Sunday } let numberOfWeek = Weekday.allCases.count print(numberOfWeek) // 7 let randomDay = Weekday.allCases.randomElement() print(randomDay.unsafelyUnwrapped) for day in Weekday.allCases { print(day) } // same as above Weekday.allCases.forEach { print($0) } // Monday // Tuesday // Wednesday // Thursday // Friday // Saturday // Sunday Aassociated values - 연관 값 case의 각 값에 연관 값을 할당할 수 있다.\nBut, 연관 값과 원시 값을 함께 사용할 수는 없다.\n1 2 3 4 5 6 7 8 enum Activity { case bored case running(destination: String) case talking(topic: String) case singing(volume: Int) } let talking = Activity.talking(topic: \u0026#34;football\u0026#34;) References Swift Doc - Enumerations\n100 Days Of Swift - Enum associated values\n","date":"2022-08-01T08:19:48+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/enum-%EC%97%B4%EA%B1%B0%ED%98%95/","title":"Enum 열거형"},{"content":"Literals ❓ Literal은 각 자료형에 대한 값을 표현하는 방법이다. 상수나 변수로 정의되는 데이터 그 자체 - 라고 표현하면 더 이해가 쉬울 듯 하다.\n예를 들면, 문자열 리터럴은 \u0026ldquo;Hello, World\u0026rdquo;, 정수형 리터럴은 12345 등으로 표현할 수 있다.\n공식문서를 보면서 String Literals에 대해 공부해 보았다.\nString Literals A string literal is a sequence of characters surrounded by double quotation marks (\u0026quot;).\n1 2 let someString = \u0026#34;Some string literal value\u0026#34; print(someString) // Some string literal value 한줄로 된 문자열을 정의할 때는 이렇게 하면 된다. 줄바꿈을 하고 싶은 경우에는 \\n을 사용해준다.\n1 2 3 4 let someString = \u0026#34;Some string \\n literal value\u0026#34; print(someString) // Some string // literal value Multiline String Literals 여러 줄의 문자열 리터럴을 정의할 때에는 앞,뒤로 \u0026quot;\u0026quot;\u0026quot;를 붙여주면 된다.\n1 2 3 4 5 6 7 let quotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning,\u0026#34; the King said gravely, \u0026#34;and go on till you come to the end; then stop.\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(quotation)해 보면 이렇게 출력된다.\n\u0026quot;\u0026quot;\u0026quot; 블록 안에서 줄바꿈을 하면 문자열에도 줄 바꿈이 적용되는데. 만약 코드의 가독성을 위해 줄바꿈을 하지만 문자열에는 적용되지 않게 하고 싶다면 \\를 붙여주면 된다.\n1 2 3 4 5 6 7 let softWrappedQuotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, \\ please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning,\u0026#34; the King said gravely, \u0026#34;and go on \\ till you come to the end; then stop.\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(softWrappedQuotation)해 보면 이렇게 출력된다.\n들여쓰기 기준은 뒤쪽 \u0026quot;\u0026quot;\u0026quot;앞 부분이 기준이 된다. 하단의 코드를 보면 뒤의 \u0026quot;\u0026quot;\u0026quot;앞에 4칸의 공백이 있으므로 다른 열의 4칸의 공백도 함께 무시되고, 그 이후의 들여쓰기만 적용된다.\n1 2 3 4 5 let lineWithIndentation = \u0026#34;\u0026#34;\u0026#34; This line doesn\u0026#39;t begin with whitespace This line begins with four space This line doesn\u0026#39;t begin with whitespace \u0026#34;\u0026#34;\u0026#34; print(lineWithIndentation)해 보면 이렇게 출력된다.\n이해되지 않은 부분 공식문서에서 Multiline String Literals은 \u0026quot;\u0026quot;\u0026quot;를 사용하기 때문에 하나 이상의 \u0026quot;를 이스케이프 해주면 \u0026quot;를 문자열에서 사용할 수 있다고 나와있는데\nBecause multiline string literals use three double quotation marks instead of just one, you can include a double quotation mark (\u0026quot;) inside of a multiline string literal without escaping it. To include the text \u0026quot;\u0026quot;\u0026quot; in a multiline string, escape at least one of the quotation marks. For example:\n1 2 3 4 let threeDoubleQuotationMarks = \u0026#34;\u0026#34;\u0026#34; Escaping the first quotation mark \\\u0026#34;\u0026#34;\u0026#34; Escaping all three quotation marks \\\u0026#34;\\\u0026#34;\\\u0026#34; \u0026#34;\u0026#34;\u0026#34; 이 코드를 XCode로 실행하면 \u0026quot;\u0026quot;\u0026quot; 뒷부분도 문자열로 인식된다.\n심플한 코드를 만들어서 확인해 보았다. Xcode상에서 이후의 코드가 주황색으로 보여지긴 하지만 빌드도, 실행도 잘 되어진다.\n이런 거 Apple에 보고하려면 어떻게 해야 하는지 아시는 분?\nReference Swift Docs - Strings and Characters\n","date":"2022-07-29T11:19:36+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1659064694/curious2_ovngaz.jpg","permalink":"https://JaeKimdev.github.io/p/string-literals/","title":"String Literals"},{"content":"Optional - 값이 있을 수도 있고 없을 수도 있음을 의미. 변수명 뒤에 ?를 붙여서 옵셔널을 선언해줌. Optional\u0026lt;String\u0026gt;으로 표현해줄 수도 있음.\n1 2 3 4 5 6 7 8 9 10 // non-optional var name: String = \u0026#34;Jae\u0026#34; name = nil // Error // optional var name: String? = \u0026#34;Jae\u0026#34; print(name) // Optional(\u0026#34;Jae\u0026#34;) name = nil print(name) // nil Swift에서 옵셔널의 정의 ➡️ 옵셔널은 열거형으로 정의되어 있고, nil일 경우에는 none 케이스가 될 것이고, 값이 있을 때는 some 케이스가 되게 된다.\n1 2 3 4 5 6 7 8 9 10 11 public enum Optional\u0026lt;Wrapped\u0026gt; : ExpressibleByNilLiteral { case none /// The presence of a value, stored as `Wrapped`. case some(Wrapped) public init(_ some: Wrapped) ... } Unwrapping 언래핑 optional String 타입의 변수 name을 출력해보면 Optional(\u0026quot;Jae\u0026quot;)와 같이 출력되기 때문에 자료형을 사용하기 위해서는 Optional에서 값을 꺼내와야 한다. 이것을 Unwrapping 이라고 부른다.\n‼️ unwarpping 하고자 하는 값이 nil이면 언래핑을 할 수 없다.\nForced Unwrapping 강제추출 무조건 변수가 있는 상황이 보장된다면 뒤에 느낌표!를 붙여서 강제추출을 할 수 있다.\n1 2 3 4 5 6 var name: String? = \u0026#34;Jae\u0026#34; print(name!) // Jae // 사용자 입력을 받는 `ReadLine` 함수에서 이렇게 사용하기도 한다. // 가장 간단한 방법이지만, 가장 위험한 방법이기 때문에 되도록이면 사용하지 않는 것이 좋다. name = Readline()! Optional Binding 옵셔널 바인딩 값이 nil인지 확인하고 값이 있으면 값을 언래핑하는 방법을 Optional Binding 이라고 부른다.\nif let과 let var를 사용한다.\n- if let if문 안의 조건문이 nil인지 아닌지를 체크하고 nil이 아니라면 해당 블럭이 실행된다.\n1 2 3 4 5 6 7 var name: String? = \u0026#34;Jae\u0026#34; if let name = name { print(name) } else { print(\u0026#34;name is nil\u0026#34;) } name 값을 가지고 있는 경우 이름이 출력되고, name이 nil인 경우 \u0026ldquo;name is nil\u0026quot;이 출력된다.\n- guard let guard 조건문이 참이 아니면 else 문이 실행되는 문법이다. else문 안에는 코드 블럭을 종료하는 continue, break, return, throw를 반드시 사용해야 한다.\n‼️ guard let 으로 선언한 상수는 guard문 밖에서도 사용이 가능하다.\n1 2 3 4 5 6 7 var name: String? = \u0026#34;Jae\u0026#34; guard let name = name else { print(\u0026#34;name is nil\u0026#34;) return } print(name) Nil Coalescing Operator - nil 병합 연산 값이 없는 경우 기본 타입 변수를 지정해주는 방식\n1 2 var name: String? = \u0026#34;Jae\u0026#34; print(\u0026#34;userName : \\(name ?? \u0026#34;Stranger\u0026#34;)\u0026#34;) name이 있는 경우에는 이름이 출력되고, name이 nil인 경우애는 Stranger가 출력된다.\n조건 연산자를 이용하는 것도 가능하다.\n1 2 3 4 5 var name: String? = \u0026#34;Jae\u0026#34; var displayName = \u0026#34;Hello, \u0026#34; + (name != nil ? name! : \u0026#34;Stranger\u0026#34;) var displayName = \u0026#34;Hello, \u0026#34; + (name ?? \u0026#34;Stranger\u0026#34;) //same as above print(displayName) Optional Chaining - 옵셔널 체이닝 옵셔널을 연달아 호출하기\nOptional Chaining의 결과는 항상 Optional이다.\nOptional Chaining 중 하나라도 nil값이 있다면 이후 표현식은 체크하지 않고 바로 nil을 리턴한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 옵셔널 체이닝을 사용하지 않는다면... func guardJob(owner: Person?) { if let owner = owner { if let home = owner.home { if let `guard` = home.guard { if let guardJob = `guard`.job { print(\u0026#34;우리집 경비원의 직업은 \\(guardJob)입니다\u0026#34;) } else { print(\u0026#34;우리집 경비원은 직업이 없어요\u0026#34;) } } } } } guardJob(owner: yagom) // 옵셔널 체이닝을 사용한다면 func guardJobWithOptionalChaining(owner: Person?) { if let guardJob = owner?.home?.guard?.job { print(\u0026#34;우리집 경비원의 직업은 \\(guardJob)입니다\u0026#34;) } else { print(\u0026#34;우리집 경비원은 직업이 없어요\u0026#34;) } } guardJobWithOptionalChaining(owner: yagom) ","date":"2022-07-28T19:28:48+08:00","image":"https://res.cloudinary.com/dwrejmale/image/upload/v1658929900/swift_dpaoqx.png","permalink":"https://JaeKimdev.github.io/p/%EC%98%B5%EC%85%94%EB%84%90-optional/","title":"옵셔널 (Optional)"},{"content":"🌱 Intro 🧑🏻‍💻 40대에 개발자를 꿈꾸는 호주사는 비 전공자 아저씨.\n나를 한 문장으로 정의하자면 이렇다.\n대학에서는 생명과학을 전공하고 IT 업계에서 소프트웨어 테스팅 업무 7년간,\n호주로 이민을 오고나서는 컴퓨터와는 관계없는 일을 7년간 하고 개발 공부를 시작하게 되었다.\n개발을 하겠다고 생각한 후, 1년 반 과정의 Diploma of Advanced Computer Programing 코스(한국의 2년제 대학과정)를 시작하고 1년간 C#, Java, Python을 공부하였는데 맛보기로 조금씩만 배우는 느낌이어서 취업을 할 수 있을지가 고민이 되었고 그래서 부트캠프를 알아보던 중 야곰 아카데미를 알게 되었다.\n애플 제품은 이미 2011년부터 맥북 프로를 시작으로 아이폰, 아이패드, 아이맥, 애플워치, 애플TV를 사용하고 있었고 그동안의 사용자 경험이 충분히 만족스러웠기 때문에 iOS 개발을 선택하였다.\n호주의 iOS 점유율은 약 50% 정도 되는 것 같다.\n삼페보다는 Apple Pay가 짱! GOS되는 삼성은 버려!\n출처: https://gs.statcounter.com/os-market-share/mobile/australia 출처: https://www.kantarworldpanel.com/global/smartphone-os-market-share/ 일단 100% 온라인으로 진행되기 때문에 모든 과정에 참여가 가능했고, 개념을 익히는 것이기 때문에 언어의 장벽이 없는 것이 더 좋을 것이라 판단했다.\n기초 지식이 있는 사람을 대상으로 하는 [커리어 스타터 캠프]와는 달리 코드 스타터 캠프는 입금순으로 등록이 되기 때문에 지체없이 등록 ㄱㄱ\n가격은 5주 과정에 55만원이다. 먼저 수료한 사람들의 후기를 찾아보면서 가격이 잘 보이지 않아 한참 검색했던 기억이\u0026hellip;\n🌱 아카데미 과정 아카데미 과정은 주차별로 진행이 되고, 각각의 주차 월요일에 그 주차의 학습 컨텐츠, 미션이 공개된다. 한꺼번에 몰아서 할 수는 없다.\n시작 전 미리 학습페이지에 들어가서 Week 0에 있는 기본CS 지식과 git 사용법을 익혀두면 도움이 많이 된다.\n시간이 있는 사람은 야곰유튜브 - Swift 기초강의를 한번 쭉 듣고오면 좋을 것 같다. 💻 디스코드 채널 일주일에 한번 2시간씩 진행되는 줌 세션을 제외하면, 모든 소통은 디스코드에서 이루어진다.\n서버 내의 채널이 세분화 되어 있고, 각각의 채널을 선택하여 진행할 수 있다.\n함께 모여서 각자의 화면을 공유해놓고 공부하기도 하고, 음성채널에서 음악봇으로 음악을 틀어놓고 수다를 떨기도 한다. 같은 주제, 같은 자료를 가지고 함께 공부하다보니 동질감이 있어서 더 재미있었다.\n가끔은 학습 도우미분이 디스코드 채널에서 화면을 공유해주면서 캠퍼에게 모르는 것을 알려주기도 한다. 나도 같이 듣고 싶은데.. 부끄러워서 들어가보진 않았다.\n📖 학습자료 주차별 학습자료는 Swift 문법을 설명해주는 글과 중간에 STEP 1, 2, 3으로 불리는 미션이 있다.\n문법 강좌를 몇개 듣고 진행하면 그 주에 배운 문법을 사용하는 과제 STEP 1을 만나게 되고 XCode로 작성하여 PR을 보내면 담당 학습도우미가 리뷰를 하고 리뷰 내용을 반영하여 리팩토링하고 merge를 하게된다.\n리뷰를 기다리는 동안 미흡했던 내용을 찾아보거나 다음 학습자료 공부를 진행하는 식으로 진행된다.\n학습자료는 그냥 쭉 따라가며 따라치는 방법으로는 배울 수 없고 중간중간 간극이 존재한다.\n혼자 삽질도 해보고, 오류메세지를 구글에 검색하면서 얻는 지식도 많이 있다. 읽으면서 진행할 땐 알 것 같다가도 미션을 진행하다보면 아리까리 해서 학습자료를 앞뒤로 왔다리 갔다리.. 삽질을 하다보면 깨닫는 사실은 일부러 이렇게 만들었구나~ 하는 생각이었다.\n예를 들면 예제에서는 String 타입에 대해서만 나와있었는데 미션을 진행할 때에는 다른 타입으로 사용을 해야 하니 바로 가져다 쓸 수는 없고 고민에 고민을 거듭해서 사용을 해야 한다.\nif let만 배웠으니 사용했는데 guard let과 무엇이 다른지 어떤 것이 더 좋은지 질문이 나온다. 계속해서 고민하고 찾아보는 것이 좋다.\n이전 주차 마지막 STEP 까지 진행을 하지 않으면 다음 주차를 진행할 수가 없어서 캠퍼(캠프 참가자들을 캠퍼라고 부른다)들은 각각 다른 진도로 진행을 하게 된다. 상대적으로 직장이나 학업과 병행하는 분들이 시간을 많이 들일 수 없어서 뒤쳐지는 경우를 보았는데 적지않은 돈을 들여 배우는 만큼 캠프 등록 시 학습을 위한 어느정도의 시간을 확보해 놓는 것이 좋을 것 같다.\n캠프 기간이 종료되어도 디스코드 채널은 2주간, 학습 페이지는 6개월동안 접속이 가능하여 계속해서 공부할 수 있긴 하다. 나도 리뷰 작성이 완료되면 다시한번 배운 것들을 차근차근 정리해 놓으려고 한다.\n😀 학습도우미 개인적으로는 야곰아카데미에서 가장 좋은 부분이 담당 학습도우미이지 않을까 싶다.\n미션 진행시 담당도우미를 태그해서 PR을 보내면 도우미가 리뷰를 진행한다. 단순히 모르는 것을 질문하는 것이 아니라 code convention, Syntax, 빠지거나 추가할 부분\u0026hellip; 등을 알려주게 된다.\n\u0026ldquo;네이밍은 왜 이렇게 하셨나요?\u0026rdquo;\n\u0026ldquo;이 코드는 사용되지 않는 것 같네요~\u0026rdquo;\n\u0026ldquo;구조를 다시 생각해 보셨으면 좋겠어요~\u0026rdquo;\n\u0026ldquo;제가 생각한 것보다 더 좋아요~\u0026rdquo;\n\u0026ldquo;이렇게 바꿔보시면 좋을 것 같아요\u0026hellip;\u0026rdquo;\n등등, 코드를 다 작성하고 실행까지 완벽하게 되는구나 하고 PR을 보내도 항상 배울 것이 많음을 느끼는 좋은 시간이었다.\n담당 도우미별로 스타일이 다를 수 있기 때문에 시간 여유가 있는 사람은 다른 사람의 리뷰 내용도 확인해보면 더더더 많이 배울 수 있다. 나는 다른사람들이 쓴 TIL과 미션내용을 다 읽었다.\n살짝 아쉬웠던 부분은 3주차 후반부터 나의 담당도우미분이 많이 바빠보여서 수요일에 보낸 리뷰가 금요일까지 되지 않았던 적이 있었고 - PR알림을 놓친것 같다고 하셨다. - 그 후에도 계속 PR을 보내고 나서 하루 반정도 후에 리뷰가 되어 많이 아쉬웠다. 상대적으로 앞주차보다는 많이 못 배운것 같은 아쉬움이 남는다.\n🧑🏻‍💻 TIL(Today I Learned) 캠프에서는 그날 그날 배운 것들을 TIL로 정리해서 올리는 것을 장려하고 있다.\n매일 오후 5시에 TIL / 일일회고 티켓이 발행이 되고, 작성하면 캠프 페이지 메인에 github와 같이 파란색 잔디가 심겨진다.\n다른 캠퍼들이 고민하고 공부한 것들을 보면서 자극이 되기도 하고, 몰랐던 부분을 알게되어 좋았다.\n여기에 적어둔 것을 보고 일주일에 한번 있는 피드백 세션에서 좀 더 자세히 설명을 해 주기도 한다.\n개발 공부를 시작하면서 나도 1일 1잔디 심기를 하고 있는데, 조금 더 마크다운 사용법에 익숙해져야 겠다는 생각도 하게 되었고, 내가 고민했던 점을 잘 정리해 놓을 개발 블로그도 시작해야겠다는 동기부여가 되었다.\n📚 스터디 1주차가 시작되면서 스터디 결성을 위한 설문조사를 하고 참여 가능한 요일과 시간대를 제출하면 그에 따라 스터디를 묶어준다. 5기에서는 매주 수요일 오전반(9-1시), 오후반(1-5시), 저녁반(7-11시) 이렇게 분류해 주었던 것 같다.\n스터디라는 걸 학교다니면서도 해보지 않아서 어떻게 해야하는지 고민했는데 우리 그룹은 함께 디스코드 채널에 들어와서 자신이 공부하고 있는 화면 공유를 하고 각자 공부를 진행하였다.\n다른 그룹은 50분 공부하고 10분동안 자신이 공부한 것을 나누는 그룹도 있었던 것 같다.\n아무래도 30명에 달하는 캠퍼들을 다 알 수는 없어서 같은 스터디 그룹원과 친해지고 궁금한 것도 물어보고 하게 되는 것 같으니 스터디는 왠만하면 참여하는 것이 좋다고 생각한다.\n❓ 질문 잘 정리하기 학습을 진행하다가 모르는 것이 있으면 디스코드 #질문-답변 채널에 물어보면 많은 분들이 친절하게 알려주신다.\n질문을 할 때에는 어떤 점이 궁금한지, 어떤 것을 찾아보았는지, Swift 공식 문서는 어떻게 말하고 있는지.. 잘 정리해서 질문하면 더 빠른 이해가 가능하다.\n물론 물어본 것에 대해 바로바로 답변을 해주지는 않는다. \u0026quot; ㅇㅇ는 어떻게 생각하시나요? \u0026ldquo;, \u0026quot; 에러 메세지는 무슨 뜻인가요? \u0026quot; 등 약간 선문답같다는 생각이 들 때도 있다.\n많은 사람이 함께 들어와 있는 대화방이다 보니, 그렇게 질문이 끝나버리기도 하는데, 이해가 잘 안되면 그냥 넘어가지 말고 질문을 정리해서 다시 물어보거나 조금 더 찾아보는 것을 추천한다.\n우리는 초보들이고 모르는 것이 당연하다. 그래도 잘 모르겠다면 담당 도우미에게라도 물어보자!\n🌱 Outro 올해 진행되고 있는 애플 아카데미 최고령자가 42세 라는 이야기를 iOS 개발자 단톡방에서 보았다.\n여기 호주는 나이를 물어보지 않고 50대에 치킨집 창업 🍗 을 고민하지 않아도 되어, 한국보다는 상황이 조금 낫지 않을까 하는 생각이 들지만, 여전히 인터넷에서는 비전공자, 30대 라는 키워드로 개발공부를 시작해도 되는지 질문이 많이 올라오는 것 같다. (우리 모두 힘내요~ 💪)\n지금 나는 야곰 아카데미의 커리어 스타터 캠프 7기 사전과제를 마치고 기다리는 중이다. 꼭 합격해야 할텐데..\niOS 개발자를 위한 첫걸음인 코드 스타터 캠프, 그리고 심화과정(?)인 커리어 스타커 캠프를 잘 마무리하고 나만의 앱을 만드는 그날까지, 계속해서 공부하고 질문하는 개발자가 될 수있도록 하는 밑거름을 만드는 시간이었다 생각한다.\n앞으로 주변에 iOS 개발을 하고 싶다고 물어보는 사람이 있다면, 망설이지 않고 코드 스타터 캠프를 추천해 줄 수 있을 것 같다.\n‼️ 5기를 함께했던 캠퍼 중에 언제 iOS 개발을 배우는지 물어보는 사람이 있었던 것 같았는데, 코드 스타터 캠프에서는 Swift 문법 만을 배우고 iOS는 쳐다도 보지 않는다.\n당장 iOS 화면을 만들고 구동하고 싶은 사람은 코드 스타터 캠프가 맞지 않을 수 있으니 다시 한번 생각해보길..\n","date":"2022-07-27T10:46:27+08:00","image":"https://JaeKimdev.github.io/post/review/220727-2.png","permalink":"https://JaeKimdev.github.io/p/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%8A%A4%ED%83%80%ED%84%B0-%EC%BA%A0%ED%94%84-5%EA%B8%B0-%ED%9B%84%EA%B8%B0/","title":"스위프트 코드 스타터 캠프 5기 후기"},{"content":"새로운 글 작성하기 신규 포스트는 터미널에 다음과 같이 입력하면 된다.\n파일명 정하기가 어려울 것 같아 날짜로 입력하기로 했다.\n1 2 3 # hugo new post/\u0026lt;폴더명\u0026gt;/파일 이름.md (폴더명 생략가능) $ hugo new post/tech/220727-1.md Content \u0026#34;/Users/smfc/Dev/blog/content/post/tech/220727-1.md\u0026#34; created blog/content/post 하단에 md 파일이 생성되고 그것을 수정해서 저장하면 된다.\n터미널에서 로컬서버를 실행하면 바로 확인이 가능하다\n1 2 3 # 로컬 서버 실행 $ hugo server -D # http://localhost:1313 접속하여 확인 작성을 다 마치고 로컬서버에서 확인 후 배포를 하면 된다.\n1 2 3 4 5 # 로컬서버 종료 ctrl + c $ git add . $ git push $ ./deploy.sh 포스트에 댓글 추가하기 참고한 gurumee92님이 하신대로 깃허브에서 blog-comments라는 이름으로 레포지토리를 하나 더 만들고 여기 utterances 사이트로 가서 \u0026lsquo;Blog Post ↔️ Issue Mapping`에서 한가지를 선택 후 바로 위쪽 repo 칸에 자신의 레포지토리 이름(JaeKimDev/blog-comments)을 넣어주고 아래쪽에 보여지는 스크립트를 복사하면 된다.\n1 2 3 4 5 6 7 \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;JaeKimDev/blog-comments\u0026#34; issue-term=\u0026#34;title\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 복사한 스크립트를 blog/themes/hugo-tranquilpeak-theme/layouts/partials/post/comment.html 파일을 열어 하단에 붙여넣어 주고 확인해보면 댓글 추가 폼이 생성되었다.\n포스트에 이미지 추가하기 어떻게 보면 간단할 수 있는데, md 파일을 수정하면서 어떻게 이미지를 넣어야 할 지 몰라서 고생했다.\nstatic 폴더 안에 image 폴더를 만들고(blog/static/image) 로컬에서 불러오는 방법\n온라인에 올리고 링크를 이용하여 불러오는 방법\n1번 방법은 blog/static/image 안에 이미지.png 파일을 추가하고 글 작성 시 ![img](/image/이미지.png) 라고 적어주면 이미지가 추가된다.\n‼️ 추가 : 경로를 \u0026ldquo;post/review/220727-2.png\u0026rdquo; 로 적어주어도 된다. 2번 방법은 온라인에 올리고 링크를 이용하여 불러오는 방법이다.\n나는 깃허브 TIL폴더 하단에 etc/images/blog폴더를 만들어서 이미지를 업로드 하고\n![img](이미지 경로) 라고 적어주었다.\n여러번 쓸 수 있을 것 같은 짤방이나 이미지는 한번만 올려두고 링크로 끌고 오는 편이 좋을 것 같다.\n만들어진 서비스를 이용하는 것이 더 편리하고 좋겠지만, git과도 좀 더 친해질 수 있고 마크다운 언어도 익숙해질 수 있을 것 같아 일단은 써보려고 한다.\nReference Github 페이지 블로그 만들기 (with Hugo) 블로그 구축기 (1) Hugo + Github으로 개인 블로그 만들기 ","date":"2022-07-27T09:23:57+08:00","image":"https://raw.githubusercontent.com/JaeKimdev/TIL/main/etc/images/blog/blog-1.avif","permalink":"https://JaeKimdev.github.io/p/hugo%EB%A1%9C-github.io-%EA%B8%B0%EC%88%A0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B02/","title":"Hugo로 github.io 기술 블로그 만들기(2)"},{"content":"개발 공부를 시작하면서부터 기술블로그를 쓰면 좋다는 이야기를 들었지만, 어디서부터 어떻게 해야 할지 몰라서 github.io 페이지를 만들고 Jekyll을 이용해서 블로그를 만들어 놓기만 한 채 방치하고 있었다.\niOS 공부를 시작하면서 공부한 것 정리용으로, 또 나중에 찾아볼 수 있도록 기록하면 좋겠다 싶어서 찾아보니 Jekyll은 컨텐츠가 쌓일수록 빌드 속도가 엄청 늦어진다는 글을 읽어서 새롭게 hugo를 사용해 보기로 했다.\n마침 야곰 아카데미 코드 스타터 5주 과정이 끝나서 리뷰를 써야겠다고 마음먹고 시작!\nHugo 설치 HomeBrew가 설치되어 있어야 한다. 여기 화면 중앙의 Install Homebrew하단의 코드를 복사해서 터미널에서 실행 1 2 3 4 5 6 7 8 # hugo 설치 $ brew install hugo # hugo 버전 확인 $ hugo version # 설치가 되어 있다면 버전이 출력된다. hugo v0.101.0+extended darwin/amd64 BuildDate=unknown Github 레포지토리 생성 blog 라는 이름의 레포지토리와 \u0026lt;username\u0026gt;.github.io 자기아이디 이름의 github.io 레포지토리를 생성해 준다\nHugo 프로젝트 만들기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # hugo 프로젝트 생성 $ hugo new site blog # 생성 완료되면 출력 문구 Congratulations! Your new Hugo site is created in /Users/user/Workspaces/blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 테마는 여기 에서 확인하고 고를 수 있는데, 나는 gurumee92님이 설치한 hugo-tranquilpeak-theme을 따라서 설치하였다. 뭣도 모르니까\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # blog 폴더로 이동 $ cd blog # 프로젝트 루트 경로 확인 $ pwd /Users/smfc/Dev/blog # git 초기화 $ git init # 브렌치를 main으로 변경 $ git branch -M main # git submodule add https://github.com/\u0026lt;theme 경로\u0026gt;.git themes/\u0026lt;theme 이름\u0026gt; $ git submodule add https://github.com/kakawait/hugo-tranquilpeak-theme.git themes/hugo-tranquilpeak-theme # 테마 폴더 안의 `config.toml` 파일을 blog 폴더 하단으로 복사 $ cp themes/hugo-tranquilpeak-theme/exampleSite/config.toml config.toml 그후 blog 폴더 하단의 config.toml 파일을 열어서 수정해준다.\n1 2 3 4 5 # 이 부분 baseURL을 자신의 github.io 주소로 수정 baseURL = \u0026#34;https://jaekimdev.github.io/\u0026#34; # 블로그 상단에 노출되는 이름 수정 title = \u0026#34;Jae\u0026#39;s Devlog\u0026#34; 저장 후 터미널에서 hugo 서버 실행\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ hugo server Start building sites … hugo v0.101.0+extended darwin/amd64 BuildDate=unknown | EN-US -------------------+-------- Pages | 9 Paginator pages | 0 Non-page files | 0 Static files | 4 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Built in 9 ms Watching for changes in /Users/smfc/Dev/blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/smfc/Dev/blog/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 브라우저를 열어서 http://localhost:1313/로 접속하면 블로그 화면을 볼 수 있다.\ngithub 레포지토리 연결 blog에 blog 레포지토리를, blog/public에 \u0026lt;username\u0026gt;.github.io 레포지토리를 연결한다.\n1 2 3 4 5 6 7 # blog -\u0026gt; blog 레포지토리 연결 # git remote add origin http://github.com/\u0026lt;username\u0026gt;/blog.git $ git remote add origin https://github.com/jaekimdev/blog.git # blog/public -\u0026gt; \u0026lt;username\u0026gt;.github.io 연결 # git submodule add -b main http://github.com/\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git public $ git submodule add -b main http://github.com/jaekimdev/jaekimdev.github.io.git public ‼️ public이 이미 존재한다는 에러 메세지가 보여지고 진행되지 않음. ➡️ blog 폴더 하단의 public 폴더를 지운 후에 명령어 실행\n배포를 쉽게 하기 위해 blog 폴더 하단에 \u0026lsquo;deploy.sh\u0026rsquo; 파일을 만들어 준다 - 나는 config.toml 파일을 복사한 후 이름을 변경해 주고 아래 내용을 붙여넣기 한 후 저장하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. # hugo -t \u0026lt;여러분의 테마\u0026gt; hugo -t hugo-tranquilpeak-theme # Go To Public folder, sub module commit cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin main # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin main 터미널에서 sh파일에 권한을 주고 실행한다.\n1 2 3 4 5 # deploy.sh 실행 파일 권한 부여 $ chmod 777 deploy.sh # 배포 실행 $ ./deploy.sh ‼️ 나는 이 부분에서 오류 발생! ➡️ 오류메세지에서 안내해 주는대로 git fetch 먼저 해주고 ./deploy.sh 재실행 ‼️ 또다시 오류 발생! ➡️ 오류메세지에서 안내해 주는대로 git pull 실행하고 git branch --set-upstream-to=origin/main실행한 후 ./deploy.sh 재실행 ‼️ 또다시 오류 발생! ➡️ 오류메세지에서 안내해 주는대로 git pull 실행하고 ./deploy.sh 재실행 내가 찾아본 블로그들에서는 이 부분을 알려주는 곳이 없어서 엄청 오랫동안 만들고 지우고를 반복;;\n이젠 다 해결되어 https://\u0026lt;username\u0026gt;.github.io로 접속해서 블로그를 볼 수 있다!!! 🎉\nReference Github 페이지 블로그 만들기 (with Hugo) 블로그 구축기 (1) Hugo + Github으로 개인 블로그 만들기 Hugo로 Github.io 블로그 만들기 ","date":"2022-07-26T15:22:52+08:00","permalink":"https://JaeKimdev.github.io/p/hugo%EB%A1%9C-github.io-%EA%B8%B0%EC%88%A0-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B01/","title":"Hugo로 github.io 기술 블로그 만들기(1)"},{"content":"My First Tech blog post!! 🎉\n☀️\n","date":"2022-07-26T11:06:26+08:00","permalink":"https://JaeKimdev.github.io/p/hugo-blog-%ED%85%8C%EC%8A%A4%ED%8A%B8/","title":"Hugo Blog 테스트"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://JaeKimdev.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://JaeKimdev.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://JaeKimdev.github.io/p/rich-content/","title":"Rich Content"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://JaeKimdev.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://JaeKimdev.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://JaeKimdev.github.io/p/emoji-support/","title":"Emoji Support"}]